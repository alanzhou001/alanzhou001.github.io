<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Alan Zhou</title><link>https://cxzhou.com/</link><description>Recent content on Alan Zhou</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 29 Oct 2025 21:36:00 +0800</lastBuildDate><atom:link href="https://cxzhou.com/index.xml" rel="self" type="application/rss+xml"/><item><title>紧性</title><link>https://cxzhou.com/p/topol-6/</link><pubDate>Wed, 29 Oct 2025 21:36:00 +0800</pubDate><guid>https://cxzhou.com/p/topol-6/</guid><description>&lt;img src="https://cxzhou.com/p/topol-6/cover.jpg" alt="Featured image of post 紧性" /&gt;&lt;p&gt;封面画师：&lt;a class="link" href="https://www.pixiv.net/artworks/113735140" target="_blank" rel="noopener"
&gt;Novi&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="紧性"&gt;紧性
&lt;/h2&gt;
&lt;div class="math-block math-block--definition" id="compactness"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 4.3.1 紧致空间&lt;/strong&gt;&lt;a href="#compactness" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;&lt;strong&gt;开覆盖 (Open Cover)&lt;/strong&gt;
设 $X$ 是一个拓扑空间 (topol. space)，$A \subset X$。
$\mathcal{O}$ 是 $X$ 中的一组开集 (a collection of open sets of $X$)。
如果 $A$ 包含在 $\mathcal{O}$ 中所有开集的并集内，则 $\mathcal{O}$ 称为 $A$ 的一个&lt;strong&gt;开覆盖&lt;/strong&gt; (open cover)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子覆盖 (Subcover)&lt;/strong&gt;
如果 $\mathcal{O}$ 覆盖了 $A$，$\mathcal{O}'$ 是 $\mathcal{O}$ 的一个子族 (subcollection) 且 $\mathcal{O}'$ 也覆盖了 $A$，则 $\mathcal{O}'$ 是 $\mathcal{O}$ 的一个&lt;strong&gt;子覆盖&lt;/strong&gt; (subcover)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;紧致空间 (Compact Space)&lt;/strong&gt;
一个拓扑空间 $X$ 是&lt;strong&gt;紧致的&lt;/strong&gt; (compact)，如果 $X$ 的每一个开覆盖都有一个&lt;strong&gt;有限子覆盖&lt;/strong&gt; (a finite subcover)。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;例 (Eg.)：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$E^1$ &lt;strong&gt;不是紧致的&lt;/strong&gt; (is not compact)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明：&lt;/strong&gt; 考虑开覆盖 $\mathcal{O} = \{(-n, n) | n \in \mathbb{Z}^+\}$。
$\bigcup_{n=1}^{\infty} (-n, n) = E^1$，所以 $\mathcal{O}$ 是 $E^1$ 的一个开覆盖。
如果 $\mathcal{O}$ 有一个有限子覆盖 $\mathcal{O}' = \{(-n_1, n_1), \ldots, (-n_k, n_k)\}$。
令 $N = \max\{n_1, \ldots, n_k\}$。则 $\bigcup_{i=1}^{k} (-n_i, n_i) = (-N, N)$。
由于 $(-N, N) \neq E^1$（例如，点 $N+1$ 不被覆盖），故 $\mathcal{O}$ 没有有限子覆盖。
因此 $E^1$ 不是紧致的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设 $X = \{x_1, x_2, \ldots, x_n\}$ 是一个有限集，则 $X$ 上的任何拓扑都是&lt;strong&gt;紧致的&lt;/strong&gt; (is compact)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明：&lt;/strong&gt; 设 $\mathcal{O}$ 是 $X$ 的任意开覆盖。对于 $\forall x_i \in X$，必存在 $U_i \in \mathcal{O}$ 使得 $x_i \in U_i$。由于 $X$ 只有 $n$ 个点，我们只需选择 $\{U_1, U_2, \ldots, U_n\}$ 这 $n$ 个开集即可覆盖 $X$。这是一个有限子覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\mathbb{R}_{fc}$（具有&lt;strong&gt;共有限拓扑&lt;/strong&gt; (cofinite topology) 的实数集 $\mathbb{R}$）是&lt;strong&gt;紧致的&lt;/strong&gt; (is compact)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明：&lt;/strong&gt;
设 $\mathcal{O}$ 是 $\mathbb{R}_{fc}$ 的一个开覆盖 (open cover)。
由于 $\mathcal{O}$ 覆盖了 $\mathbb{R}$，$\exists U \in \mathcal{O}$ 使得 $U \neq \emptyset$。
根据共有限拓扑的定义，非空开集 $U$ 的补集 $\mathbb{R} \setminus U$ 是&lt;strong&gt;有限集&lt;/strong&gt;。
记 $\mathbb{R} \setminus U = \{y_1, y_2, \ldots, y_m\}$。
$\forall y_i \in \mathbb{R} \setminus U$ (即 $y_i$ 是未被 $U$ 覆盖的点)，由于 $\mathcal{O}$ 覆盖了 $\mathbb{R}$， $\exists V_i \in \mathcal{O}$ 使得 $y_i \in V_i$。
考虑 $\mathcal{O}' = \{V_1, V_2, \ldots, V_m, U\}$。$\mathcal{O}'$ 是 $\mathcal{O}$ 的一个有限子集（包含 $m+1$ 个元素）。
&lt;/p&gt;
$$\bigcup_{i=1}^{m} V_i \cup U = (\mathbb{R} \setminus U) \cup U = \mathbb{R}$$&lt;p&gt;
因此 $\mathcal{O}'$ 是 $\mathcal{O}$ 的一个有限子覆盖。
所以 $\mathbb{R}_{fc}$ 是紧致的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>分离性与可数性</title><link>https://cxzhou.com/p/topol-5/</link><pubDate>Sun, 26 Oct 2025 14:37:00 +0800</pubDate><guid>https://cxzhou.com/p/topol-5/</guid><description>&lt;img src="https://cxzhou.com/p/topol-5/cover.jpg" alt="Featured image of post 分离性与可数性" /&gt;&lt;p&gt;封面画师：&lt;a class="link" href="https://www.pixiv.net/artworks/67467647" target="_blank" rel="noopener"
&gt;電鬼&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="分离性"&gt;分离性
&lt;/h2&gt;
&lt;div class="math-block math-block--definition" id="t3"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition3.1.2-1 T3空间&lt;/strong&gt;&lt;a href="#t3" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间 (topol. space)，如果 $X$ 满足以下条件，则称 $X$ 是&lt;strong&gt;正则空间 (Regular)&lt;/strong&gt;（$T_3$空间）：&lt;/p&gt;
&lt;p&gt;(i) $X$ 中的单点集 (one-point sets) 是闭集 (closed)；&lt;/p&gt;
&lt;p&gt;(ii) $\forall a \in X$， $\forall$ 闭集 $B \subset X$，且 $a \notin B$，存在不相交的开集 $U$ 和 $V$ (disjoint open sets $U$ and $V$)，使得 $a \in U$ 且 $B \subset V$。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Remark：&lt;/strong&gt; 正则 (regular) $\Rightarrow$ Hausdorff。&lt;/p&gt;
&lt;div class="math-block math-block--definition" id="t4"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition3.1.2-2 T4空间&lt;/strong&gt;&lt;a href="#t4" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间 (topol. space)，如果 $X$ 满足以下条件，则称 $X$ 是&lt;strong&gt;正规空间(Normal)&lt;/strong&gt;（$T_4$空间）：&lt;/p&gt;
&lt;p&gt;(i) $X$ 中的单点集 (one-point sets) 是闭集 (closed)；&lt;/p&gt;
&lt;p&gt;(ii) $\forall$ 两个不相交的闭集 $A \subset X$ 和 $B \subset X$ ($A \cap B = \emptyset$)，存在不相交的开集 $U$ 和 $V$ (disjoint open sets $U$ and $V$)，使得 $A \subset U$ 且 $B \subset V$。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Remark：&lt;/strong&gt; 正规 (normal) $\Rightarrow$ 正则 (regular)。&lt;/p&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;分离公理 (Separation axiom)&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
$$\text{Normal (T}_4) \subset \text{regular} \subset \text{Hausdorff} \quad (\text{注：} \text{T}_3 \text{通常指正则且 } T_1 \text{，} T_2 \text{指 Hausdorff})$$
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;命题：每个度量空间（metric space）都是正规空间（$T_4$，nomal）&lt;/strong&gt;&lt;/p&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;要证明一个空间 $X$ 是正规空间，需要证明两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$X$ 中每个单点集都是闭集。&lt;/li&gt;
&lt;li&gt;$\forall$ 两个不相交的闭集 $A, B \subset X$，存在不相交的开集 $U$ 和 $V$，使得 $A \subset U$ 且 $B \subset V$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;1. 单点集是闭集：&lt;/strong&gt;
在度量空间中，每个单点集都是闭集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 分离不相交闭集：&lt;/strong&gt;
假设 $X$ 是一个度量空间，$A$ 和 $B$ 是 $X$ 中两个不相交的闭集 (disjoint closed sets)。
定义函数 $g: X \rightarrow E^1$ 和 $h: X \rightarrow E^1$:
&lt;/p&gt;
$$g(x) = d(x, A) := \inf\{d(x, a) | a \in A\}$$&lt;p&gt;
&lt;/p&gt;
$$h(x) = d(x, B) := \inf\{d(x, b) | b \in B\}$$&lt;p&gt;
定义函数 $f: X \rightarrow E^1$:
&lt;/p&gt;
$$f(x) = \frac{d(x, A)}{d(x, A) + d(x, B)}$$&lt;p&gt;整个证明分为三个步骤：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) 证明 $g$ 和 $h$ 是连续的 (continuous)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要证明 $g$ 连续，只需证明 $\forall x \in X$ 和 $\forall \epsilon &gt; 0$，存在 $\delta$ 使得 $d(x, y) &lt; \delta \Rightarrow |g(y) - g(x)| &lt; \epsilon$。&lt;/p&gt;
&lt;p&gt;对于 $\forall (r, s) \subset E^1$，我们证明 $g^{-1}((r, s))$ 是 $X$ 中的开集。
$\forall x \in g^{-1}((r, s))$，我们找到 $\epsilon &gt; 0$ 使得 $B(x, \epsilon) \subset g^{-1}((r, s))$。
选取 $\epsilon &gt; 0$，使得 $(g(x) - \epsilon, g(x) + \epsilon) \subset (r, s)$。
即满足 $g(x) - \epsilon &gt; r$ 和 $g(x) + \epsilon &lt; s$。&lt;/p&gt;
&lt;p&gt;对于 $\forall y \in B(x, \epsilon)$，有 $d(x, y) &lt; \epsilon$。
利用三角不等式证明 $|g(y) - g(x)| &lt; \epsilon$：
&lt;/p&gt;
$$\begin{aligned} g(y) &amp;= d(y, A) = \inf\{d(y, a) | a \in A\} \\ &amp;\le \inf\{d(y, x) + d(x, a) | a \in A\} \\ &amp;= d(y, x) + \inf\{d(x, a) | a \in A\} \\ &amp;= d(y, x) + d(x, A) \\ &amp;&lt; \epsilon + g(x) \le s \end{aligned}$$&lt;p&gt;
&lt;/p&gt;
$$\begin{aligned} g(x) &amp;= d(x, A) \le d(x, y) + d(y, A) \\ &amp;&lt; \epsilon + g(y) \\ \Rightarrow g(y) &amp;&gt; g(x) - \epsilon &gt; r \end{aligned}$$&lt;p&gt;
因此 $g(y) \in (r, s)$。故 $B(x, \epsilon) \subset g^{-1}((r, s))$。
所以 $g^{-1}((r, s))$ 是 $X$ 中的开集，$g$ 是连续的。
类似地，$h$ 也是连续的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) 证明分母 $d(x, A) + d(x, B) &gt; 0, \forall x \in X$。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们知道 $d(x, A) = 0 \iff x \in \overline{A}$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“$\Leftarrow$” (即 $x \in A \Rightarrow d(x, A) = 0$) 是显然的 (obvious)。&lt;/li&gt;
&lt;li&gt;“$\Rightarrow$” (即 $d(x, A) = 0 \Rightarrow x \in A$): 假设 $x \notin A$。因为 $A$ 是闭集 (closed)，所以 $X \setminus A$ 是开集。$\exists \epsilon &gt; 0$，使得 $B(x, \epsilon) \subset X \setminus A$。这意味着对于 $A$ 中的所有点 $a$ 都有 $d(x, a) \ge \epsilon &gt; 0$。因此 $d(x, A) = \inf\{d(x, a) | a \in A\} \ge \epsilon &gt; 0$。这与 $d(x, A) = 0$ 矛盾 (Contradiction)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 $d(x, A) + d(x, B) = 0$，则 $d(x, A) = 0$ 且 $d(x, B) = 0$。
根据上面证明的结论， $d(x, A) = 0 \Rightarrow x \in A$ 且 $d(x, B) = 0 \Rightarrow x \in B$。
所以 $x \in A \cap B$。但这与 $A \cap B = \emptyset$ 矛盾 (Contradiction)。
因此 $d(x, A) + d(x, B) &gt; 0, \forall x \in X$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(iii) 构造分离开集：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由 (i) 和 (ii) 可知，$f$ 是连续的 (continuous)。
对于 $\forall a \in A$：
&lt;/p&gt;
$$f(a) = \frac{d(a, A)}{d(a, A) + d(a, B)} = \frac{0}{0 + d(a, B)} = 0$$&lt;p&gt;
对于 $\forall b \in B$：
&lt;/p&gt;
$$f(b) = \frac{d(b, A)}{d(b, A) + d(b, B)} = \frac{d(b, A)}{d(b, A) + 0} = 1$$&lt;p&gt;
令 $U = f^{-1}((-\infty, \frac{1}{2}))$， $V = f^{-1}((\frac{1}{2}, +\infty))$。
由于 $f$ 连续，且 $(-\infty, \frac{1}{2})$ 和 $(\frac{1}{2}, +\infty)$ 是 $E^1$ 中的开集，故 $U$ 和 $V$ &lt;strong&gt;都是开集&lt;/strong&gt; (Both $U$ and $V$ are open)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A \subset U$ (因为 $f$ 在 $A$ 上取值 $0 &lt; 1/2$)。&lt;/li&gt;
&lt;li&gt;$B \subset V$ (因为 $f$ 在 $B$ 上取值 $1 &gt; 1/2$)。&lt;/li&gt;
&lt;li&gt;$U \cap V = \emptyset$ (因为 $f$ 的值不可能同时小于 $1/2$ 和大于 $1/2$)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此， $X$ 是正规空间。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="可数性"&gt;可数性
&lt;/h2&gt;
&lt;div class="math-block math-block--definition" id="c1"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition3.1.3 第一可数空间&lt;/strong&gt;&lt;a href="#c1" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
一个拓扑空间 $X$ 在点 $x$ 处具有&lt;strong&gt;可数邻域基&lt;/strong&gt; (countable neighborhood basis)，如果存在一个 $x$ 的可数邻域族 $\{U_n\}_{n \in \mathbb{Z}^+}$，使得 $x$ 的任何邻域 $W$ 都包含其中一个 $U_n$，即 $x \in U_n \subset W$。
如果 $X$ 在其每一个点处都具有可数邻域基，则称 $X$ 是&lt;strong&gt;第一可数空间&lt;/strong&gt; (first countable)，或满足&lt;strong&gt;第一可数公理&lt;/strong&gt; (first countability axiom)。
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;例 (Eg.)：&lt;/strong&gt;
每个&lt;strong&gt;度量空间&lt;/strong&gt; $(X, d)$ 都是&lt;strong&gt;第一可数空间&lt;/strong&gt; (1st countable)。&lt;/p&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;$\forall x \in (X, d)$，定义可数邻域族 $\{U_n = B(x, \frac{1}{n})\}_{n \in \mathbb{Z}^+}$。这个族是 $x$ 的一个可数邻域基 (countable nbhd basis)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（补充：）&lt;/strong&gt; 设 $W$ 是 $x$ 的任意邻域。则存在一个开集 $V$ 使得 $x \in V \subset W$。由于 $V$ 是开集，存在 $\epsilon &gt; 0$ 使得 $B(x, \epsilon) \subset V$。根据阿基米德性质，存在正整数 $N$ 使得 $\frac{1}{N} &lt; \epsilon$。令 $U_N = B(x, \frac{1}{N})$，则 $x \in U_N \subset B(x, \epsilon) \subset V \subset W$。因此 $\{U_n\}$ 是一个可数邻域基。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="c1"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition3.1.4 第二可数空间&lt;/strong&gt;&lt;a href="#c1" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;如果一个空间 $X$ 具有一个&lt;strong&gt;可数基&lt;/strong&gt; (countable basis) 作为其拓扑的基，则称 $X$ 是&lt;strong&gt;第二可数空间&lt;/strong&gt; (second countable)，或满足&lt;strong&gt;第二可数公理&lt;/strong&gt; (second countability axiom)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例 (Eg.)：&lt;/strong&gt;
$E^n$ 是&lt;strong&gt;第二可数空间&lt;/strong&gt; (second countable)。
&lt;strong&gt;证明：&lt;/strong&gt; $\mathcal{B} = \{B(x, \frac{1}{k}) | x \in E^n, x \text{的每个坐标都是有理数}, k \in \mathbb{Z}^+\}$ 是一个可数基 (countable basis)。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;命题 (Proposition)：&lt;/strong&gt;
&lt;strong&gt;第二可数&lt;/strong&gt; (2nd countable) $\Rightarrow$ &lt;strong&gt;第一可数&lt;/strong&gt; (1st countable)。&lt;/p&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;假设 $X$ 是第二可数空间。设 $\mathcal{B}$ 是 $X$ 的一个可数基 (countable basis)。&lt;/p&gt;
&lt;p&gt;$\forall x \in X$，定义 $\mathcal{B}_x = \{B \in \mathcal{B} | x \in B\}$。
由于 $\mathcal{B}$ 是可数的， $\mathcal{B}_x$ 也是可数的。&lt;/p&gt;
&lt;p&gt;$\mathcal{B}_x$ 是 $x$ 的一个可数邻域基 (countable nbhd basis at $x$)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（补充：）&lt;/strong&gt; 设 $W$ 是 $x$ 的任意邻域。则 $W$ 是开集（或包含一个开集 $V$）。由于 $\mathcal{B}$ 是基，存在 $B \in \mathcal{B}$ 使得 $x \in B \subset W$。根据 $\mathcal{B}_x$ 的定义， $B \in \mathcal{B}_x$。因此 $\mathcal{B}_x$ 满足可数邻域基的定义，故 $X$ 是第一可数空间。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Remark：&lt;/strong&gt;
具有&lt;strong&gt;离散拓扑&lt;/strong&gt; (discrete topology) 的 $\mathbb{R}$ 不是第二可数空间 (is not 2nd countable)。但是它却是&lt;strong&gt;可度量化&lt;/strong&gt;的 (metrizable)。&lt;/p&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;定理 2&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;子空间：&lt;/strong&gt; 第一（第二）可数空间的子空间是第一（第二）可数空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;乘积：&lt;/strong&gt; 两个第一（第二）可数空间的乘积是第一（第二）可数空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;&lt;strong&gt;第二可数情况 (2nd countable case)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) 子空间：$X$ 是第二可数 $\Rightarrow A \subset X$ 是第二可数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设 $X$ 是第二可数空间，$\mathcal{B}$ 是 $X$ 的一个可数基 (countable basis)。&lt;/p&gt;
&lt;p&gt;设 $A \subset X$ 是一个子空间 (subspace)。&lt;/p&gt;
&lt;p&gt;则 $\mathcal{B}_A = \{B \cap A | B \in \mathcal{B}\}$ 是 $A$ 的拓扑的一个基。
由于 $\mathcal{B}$ 是可数的，因此 $\mathcal{B}_A$ 也是可数的。&lt;/p&gt;
&lt;p&gt;所以 $A$ 是第二可数空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 乘积：$X_1, X_2$ 是第二可数 $\Rightarrow X_1 \times X_2$ 是第二可数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设 $X_1, X_2$ 是第二可数空间。&lt;/p&gt;
&lt;p&gt;设 $\mathcal{B}_i$ 是 $X_i$ 的一个可数基，其中 $i=1, 2$。&lt;/p&gt;
&lt;p&gt;则 $\mathcal{B} = \{B_1 \times B_2 | B_1 \in \mathcal{B}_1, B_2 \in \mathcal{B}_2\}$ 是乘积空间 $X_1 \times X_2$ 的拓扑的一个基。&lt;/p&gt;
&lt;p&gt;由于 $\mathcal{B}_1$ 和 $\mathcal{B}_2$ 都是可数的，因此它们的笛卡尔积 $\mathcal{B}$ 也是可数的。&lt;/p&gt;
&lt;p&gt;所以 $X_1 \times X_2$ 是第二可数空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一可数情况 (1st countable case)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1) 子空间：$X$ 是第一可数 $\Rightarrow A \subset X$ 是第一可数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\forall a \in A$，因为 $X$ 是第一可数，所以 $a$ 在 $X$ 中有一个可数邻域基 $\mathcal{U} = \{U_n\}_{n \in \mathbb{Z}^+}$。&lt;/p&gt;
&lt;p&gt;我们证明 $\mathcal{U}_A = \{U_n \cap A | U_n \in \mathcal{U}\}$ 是 $a$ 在子空间 $A$ 中的一个可数邻域基。&lt;/p&gt;
&lt;p&gt;显然 $\mathcal{U}_A$ 是可数的。&lt;/p&gt;
&lt;p&gt;设 $W$ 是 $a$ 在 $A$ 中的任意邻域。根据子空间拓扑的定义，存在 $X$ 中的开集 $V$，使得 $W = V \cap A$。&lt;/p&gt;
&lt;p&gt;由于 $V$ 是 $a$ 在 $X$ 中的邻域，且 $\mathcal{U}$ 是 $a$ 在 $X$ 中的可数邻域基，因此 $\exists U_n \in \mathcal{U}$ 使得 $a \in U_n \subset V$。&lt;/p&gt;
&lt;p&gt;那么 $a \in U_n \cap A \subset V \cap A = W$。&lt;/p&gt;
&lt;p&gt;因此 $\mathcal{U}_A$ 是 $a$ 在 $A$ 中的一个可数邻域基。所以 $A$ 是第一可数空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 乘积：$X_1, X_2$ 是第一可数 $\Rightarrow X_1 \times X_2$ 是第一可数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\forall (x_1, x_2) \in X_1 \times X_2$。&lt;/p&gt;
&lt;p&gt;由于 $X_i$ 是第一可数， $x_i$ 在 $X_i$ 中有一个可数邻域基 $\mathcal{U}_i = \{U_{i, n}\}_{n \in \mathbb{Z}^+}$，其中 $i=1, 2$。&lt;/p&gt;
&lt;p&gt;我们证明 $\mathcal{U} = \{U_{1, n} \times U_{2, m} | n, m \in \mathbb{Z}^+\}$ 是 $(x_1, x_2)$ 在 $X_1 \times X_2$ 中的一个可数邻域基。&lt;/p&gt;
&lt;p&gt;由于 $\mathbb{Z}^+ \times \mathbb{Z}^+$ 是可数的，所以 $\mathcal{U}$ 是可数的。&lt;/p&gt;
&lt;p&gt;设 $W$ 是 $(x_1, x_2)$ 在 $X_1 \times X_2$ 中的任意邻域。根据乘积拓扑的定义，存在基元素 $B_1 \times B_2$ 使得 $(x_1, x_2) \in B_1 \times B_2 \subset W$，其中 $B_i$ 是 $X_i$ 中的开集。&lt;/p&gt;
&lt;p&gt;由于 $\mathcal{U}_i$ 是 $x_i$ 的可数邻域基， $\exists U_{1, n} \in \mathcal{U}_1$ 和 $U_{2, m} \in \mathcal{U}_2$ 使得 $x_1 \in U_{1, n} \subset B_1$ 且 $x_2 \in U_{2, m} \subset B_2$。&lt;/p&gt;
&lt;p&gt;那么 $(x_1, x_2) \in U_{1, n} \times U_{2, m} \subset B_1 \times B_2 \subset W$。
因此 $\mathcal{U}$ 是 $(x_1, x_2)$ 的一个可数邻域基。所以 $X_1 \times X_2$ 是第一可数空间。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id="两个定理-two-theorems"&gt;两个定理 (Two Theorems)
&lt;/h3&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Urysohn 可度量化定理 (Urysohn Metrization Theorem)&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;如果一个拓扑空间 $X$ 是&lt;strong&gt;正则空间&lt;/strong&gt; (Regular) 且是&lt;strong&gt;第二可数空间&lt;/strong&gt; (2nd countable)，则 $X$ 是&lt;strong&gt;可度量化空间&lt;/strong&gt; (metrizable)。
&lt;/p&gt;
$$\text{正则} + \text{第二可数} \implies \text{可度量化}$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Tietze 扩张定理 (Tietze Extension THM)&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
设 $X$ 是一个&lt;strong&gt;正规空间&lt;/strong&gt; (normal space)， $A \subset X$ 是一个闭集 (closed)。
如果 $f: A \rightarrow E^1$ 是一个连续函数 (continuous function)，
那么存在一个连续函数 $F: X \rightarrow E^1$，使得 $F|_A = f$。
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id="例-eg"&gt;例 (Eg.)
&lt;/h4&gt;&lt;p&gt;设 $\mathbb{Z}$ 是整数集，$\mathcal{B} = \{B_{a, b} = \{a + bi | i \in \mathbb{Z}\} | a, b \in \mathbb{Z}, b \neq 0\}$ 是 $\mathbb{Z}$ 上的一个基 (basis)。它生成了 $\mathbb{Z}$ 上的一个拓扑。&lt;/p&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;&lt;strong&gt;(i) 证明 $\mathcal{B}$ 是拓扑的一个基：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;覆盖性：&lt;/strong&gt; $\forall x \in \mathbb{Z}$。取 $b=1$，则 $B_{x, 1} = \{x + 1 \cdot i | i \in \mathbb{Z}\} = \mathbb{Z}$。所以 $\mathbb{Z} = \bigcup_{B \in \mathcal{B}} B$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;交集条件：&lt;/strong&gt; 设 $B_{a_1, b_1}, B_{a_2, b_2} \in \mathcal{B}$，且 $x \in B_{a_1, b_1} \cap B_{a_2, b_2}$。
&lt;ul&gt;
&lt;li&gt;$x \in B_{a_1, b_1} \implies x = a_1 + b_1 i_1$&lt;/li&gt;
&lt;li&gt;$x \in B_{a_2, b_2} \implies x = a_2 + b_2 i_2$
要找到 $B_{a_3, b_3} \in \mathcal{B}$ 使得 $x \in B_{a_3, b_3} \subset B_{a_1, b_1} \cap B_{a_2, b_2}$。
令 $b_3 = \text{lcm}(b_1, b_2)$（最小公倍数）， $a_3 = x$。
则 $B_{x, b_3} = \{x + b_3 i | i \in \mathbb{Z}\}$。
由于 $b_3$ 是 $b_1$ 的倍数，所以 $B_{x, b_3} \subset B_{x, b_1} = B_{a_1 + b_1 i_1, b_1} = B_{a_1, b_1}$。
同理，$B_{x, b_3} \subset B_{x, b_2} = B_{a_2, b_2}$。
所以 $B_{x, b_3} \subset B_{a_1, b_1} \cap B_{a_2, b_2}$。
故 $\mathcal{B}$ 是 $\mathbb{Z}$ 上的一个基。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;(ii) 判断可数性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\mathbb{Z}$ 是&lt;strong&gt;第二可数空间&lt;/strong&gt; (2nd countable)。
因为 $\mathcal{B}$ 是&lt;strong&gt;可数&lt;/strong&gt;的。基 $\mathcal{B}$ 中的元素由 $(a, b)$ 决定，其中 $a, b \in \mathbb{Z}, b \neq 0$。 $\mathbb{Z} \times (\mathbb{Z} \setminus \{0\})$ 是可数集，故 $\mathcal{B}$ 可数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;(iii) 判断正则性：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\mathbb{Z}$ 是&lt;strong&gt;正则空间&lt;/strong&gt; (regular)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单点集是闭集：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\forall a \in \mathbb{Z}$，单点集 $\{a\}$ 是闭集。$\mathbb{Z} \setminus \{a\} = \bigcup_{b \neq 0} B_{a+1, b} \cup B_{a-1, b} \cup \cdots$。或更简单地，考虑 $B_{x, 2} = \{x, x \pm 2, \ldots\}$。$\mathbb{Z} \setminus \{a\} = \bigcup_{x \neq a} \{x\}$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点与闭集分离：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\forall a \in \mathbb{Z}$， $\forall$ 闭集 $C \subset \mathbb{Z}$， $a \notin C$。令 $V = \mathbb{Z} \setminus C$ 为 $a$ 的开邻域。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;完整证明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明单点集是闭集 (T1 条件)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\forall a \in \mathbb{Z}$，要证明 $\{a\}$ 是闭集，即 $\mathbb{Z} \setminus \{a\}$ 是开集。
$\forall x \in \mathbb{Z} \setminus \{a\}$，我们要找到 $x$ 的一个基元素邻域 $B_{x, b}$，使得 $a \notin B_{x, b}$。
$a \notin B_{x, b} \iff a \neq x + i b \text{ for any } i \in \mathbb{Z}$
$\iff a - x \neq i b \text{ for any } i \in \mathbb{Z}$
$\iff b$ 不能整除 $a - x$。&lt;/p&gt;
&lt;p&gt;由于 $a \neq x$，所以 $a - x \neq 0$。我们只需要找到一个 $b \neq 0$ 且 $b$ &lt;strong&gt;不整除&lt;/strong&gt; $a-x$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $|a-x| = 1$，取 $b = 2$。 $2$ 不整除 $\pm 1$。&lt;/li&gt;
&lt;li&gt;如果 $|a-x| &gt; 1$，取 $b = |a-x| + 1$。 $|a-x|$ 不能整除 $|a-x| + 1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;例如，取 $b = 2$。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $a$ 和 $x$ 奇偶性不同，即 $|a-x|$ 是奇数，则 $2$ 不整除 $a-x$。此时 $B_{x, 2}$ 是 $x$ 的开邻域且 $a \notin B_{x, 2}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，$\forall x \in \mathbb{Z} \setminus \{a\}$，都存在 $x$ 的一个开邻域不包含 $a$。所以 $\mathbb{Z} \setminus \{a\}$ 是开集，$\{a\}$ 是闭集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明点与闭集可分离（正则条件的核心）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\forall a \in \mathbb{Z}$ 和 $\forall$ 闭集 $C \subset \mathbb{Z}$，且 $a \notin C$。要找到不相交的开集 $U$ 和 $V$，使得 $a \in U$ 且 $C \subset V$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键性质：$B_{a, b}$ 既是开集也是闭集。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$B_{a, b}$ 是开集，因为它是基元素。&lt;/li&gt;
&lt;li&gt;$B_{a, b}$ 是闭集，因为它的补集 $\mathbb{Z} \setminus B_{a, b}$ 可以表示为其他基元素的并集：
$$\mathbb{Z} \setminus B_{a, b} = B_{a+1, b} \cup B_{a+2, b} \cup \cdots \cup B_{a+b-1, b}$$
由于每个 $B_{a+k, b}$ 都是开集，所以 $\mathbb{Z} \setminus B_{a, b}$ 是开集，即 $B_{a, b}$ 是闭集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;构造 $U$ 和 $V$：&lt;/strong&gt;
由于 $a \notin C$，且 $C$ 是闭集。我们只需要找到一个基元素 $B_{a, b}$ 满足 $B_{a, b} \cap C = \emptyset$。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于 $\forall c \in C$，由于 $a \notin C$，所以 $a \neq c$。&lt;/li&gt;
&lt;li&gt;由第 1 步证明可知，对于 $\forall c \in C$，存在 $b_c \neq 0$ 使得 $c \notin B_{a, b_c}$，即 $b_c$ 不整除 $c-a$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了分离 $a$ 和整个 $C$，我们需要一个包含 $a$ 的开集 $U$ 和包含 $C$ 的开集 $V$。
由于 $B_{a, b}$ 是闭集，其补集 $V = \mathbb{Z} \setminus B_{a, b}$ 也是开集。
我们尝试找到一个 $b$ 使得 $C \subset \mathbb{Z} \setminus B_{a, b}$，即 $C \cap B_{a, b} = \emptyset$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（对于任意闭集 $C$ 的证明较为复杂，但根据 $B_{a, b}$ 既开又闭的性质，可以采取以下简化的构造方式，这种方式在 $T_3$ 空间中常用：）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\forall a \in \mathbb{Z}$ 且 $C$ 是不包含 $a$ 的闭集。&lt;/p&gt;
&lt;p&gt;由于 $C$ 是闭集， $\mathbb{Z} \setminus C$ 是 $a$ 的开邻域。
$\mathbb{Z} \setminus C$ 是开集，可表示为基元素的并：
&lt;/p&gt;
$$\mathbb{Z} \setminus C = \bigcup_{k} B_{a_k, b_k}$$&lt;p&gt;
由于 $a \in \mathbb{Z} \setminus C$，所以 $a$ 包含在其中一个基元素中。
&lt;strong&gt;因此存在 $B_{a, b} \in \mathcal{B}$ 使得 $a \in B_{a, b} \subset \mathbb{Z} \setminus C$。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;取 $U = B_{a, b}$。则 $U$ 是 $a$ 的开邻域，且 $U \cap C = \emptyset$。
取 $V = \mathbb{Z} \setminus B_{a, b}$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$V$ 是开集（因为 $B_{a, b}$ 是闭集）。&lt;/li&gt;
&lt;li&gt;$C \subset V$（因为 $C \cap B_{a, b} = \emptyset$）。&lt;/li&gt;
&lt;li&gt;$U \cap V = \emptyset$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，$a$ 和闭集 $C$ 可以被不相交的开集 $U$ 和 $V$ 分离。
所以 $\mathbb{Z}$ 是正则空间。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>连续映射、同胚与拓扑性质</title><link>https://cxzhou.com/p/topol-4/</link><pubDate>Sun, 19 Oct 2025 16:05:00 +0800</pubDate><guid>https://cxzhou.com/p/topol-4/</guid><description>&lt;img src="https://cxzhou.com/p/topol-4/cover.jpg" alt="Featured image of post 连续映射、同胚与拓扑性质" /&gt;&lt;p&gt;封面画师：&lt;a class="link" href="https://www.pixiv.net/artworks/85649197" target="_blank" rel="noopener"
&gt;Mr.Cat&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="连续映射"&gt;连续映射
&lt;/h2&gt;
&lt;div class="math-block math-block--definition" id="cont-map"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition1.3.1 连续映射&lt;/strong&gt;&lt;a href="#cont-map" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 和 $Y$ 是两个拓扑空间，$f: X \to Y$ 是一个映射。如果对于 $Y$ 中&lt;strong&gt;任意的开集 $V$&lt;/strong&gt;，其原像 $f^{-1}(V)$ 在 $X$ 中都是&lt;strong&gt;开集&lt;/strong&gt;，则称 $f$ 是&lt;strong&gt;连续的&lt;/strong&gt;（continuous）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 (Eg.):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;恒等映射 (Id):&lt;/strong&gt; $Id: X \to X, x \mapsto x$ 是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;常值映射 (C):&lt;/strong&gt; $C: X \to Y, x \mapsto y_0$ 是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;(3) &lt;strong&gt;包含映射 ($\iota$):&lt;/strong&gt; 设 $A \subset X$。$\iota: A \to X, a \mapsto a$ 是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;(4) &lt;strong&gt;投影映射 ($\pi_i$):&lt;/strong&gt; $\pi_1: X \times Y \to X$ 和 $\pi_2: X \times Y \to Y$ 都是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="mix"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Lemma: 连续映射的复合&lt;/strong&gt;&lt;a href="#mix" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
设 $f: X \to Y$ 和 $g: Y \to Z$ 都是&lt;strong&gt;连续映射&lt;/strong&gt;，则它们的复合映射 $g \circ f: X \to Z$ 也是&lt;strong&gt;连续的&lt;/strong&gt;。
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
$$\forall \text{ open set } V \text{ in } Z, \quad (g \circ f)^{-1}(V) = f^{-1}(g^{-1}(V)) \text{ is open in } X$$
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Eg.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设 $f: X \to Y$ 是连续映射，$A \subset X$。则 $f$ 在 $A$ 上的限制 $f|_A: A \to Y$ 也是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;证明 (Pf.):&lt;/strong&gt; $f|_A$ 是 $f$ 和包含映射 $\iota: A \to X$ 的复合 $f|_A = f \circ \iota$。因为 $f$ 和 $\iota$ 都是连续的，所以 $f|_A$ 也是连续的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="连续性的判别"&gt;连续性的判别
&lt;/h3&gt;
&lt;div class="math-block math-block--theorem" id="basis-cri"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Lemma: 基元素判别法 (Basis Criterion)&lt;/strong&gt;&lt;a href="#basis-cri" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
设 $f: X \to Y$ 是一个映射，$\mathcal{B}$ 是 $Y$ 的一个&lt;strong&gt;基&lt;/strong&gt;。则 $f$ 是&lt;strong&gt;连续的&lt;/strong&gt; $\iff$ 对于 $\forall B \in \mathcal{B}$，$f^{-1}(B)$ 在 $X$ 中是&lt;strong&gt;开集&lt;/strong&gt;。
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;&lt;strong&gt;&amp;quot;$\implies$&amp;quot;：&lt;/strong&gt; (连续 $\implies$ 基元素原像开) 基元素 $B$ 本身是开集，由连续定义知 $f^{-1}(B)$ 是开集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;quot;$\impliedby$&amp;quot;：&lt;/strong&gt; (基元素原像开 $\implies$ 连续) 设 $V$ 是 $Y$ 中任意开集。 $V = \bigcup_i B_i$ ($B_i \in \mathcal{B}$)。则 $f^{-1}(V) = \bigcup_i f^{-1}(B_i)$。由假设，$f^{-1}(B_i)$ 都是开集，故其并集 $f^{-1}(V)$ 也是开集。因此 $f$ 连续。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="close-cri"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Lemma: 闭集判别法 (Closed Set Criterion)&lt;/strong&gt;&lt;a href="#close-cri" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
设 $f: X \to Y$ 是一个映射。则 $f$ 是&lt;strong&gt;连续的&lt;/strong&gt; $\iff$ 对于 $Y$ 中&lt;strong&gt;任意的闭集 $C$&lt;/strong&gt;，$f^{-1}(C)$ 在 $X$ 中是&lt;strong&gt;闭集&lt;/strong&gt;。
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;&lt;strong&gt;&amp;quot;$\implies$&amp;quot;：&lt;/strong&gt; (连续 $\implies$ 闭集原像闭) 设 $C$ 是 $Y$ 中闭集，则 $Y-C$ 是开集。因为 $f$ 连续，$f^{-1}(Y-C) = X - f^{-1}(C)$ 是开集。故 $f^{-1}(C)$ 是闭集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;quot;$\impliedby$&amp;quot;：&lt;/strong&gt; (闭集原像闭 $\implies$ 连续) 设 $V$ 是 $Y$ 中开集，则 $Y-V$ 是闭集。根据假设，$f^{-1}(Y-V)$ 是闭集。 $f^{-1}(V) = X - f^{-1}(Y-V)$ 是闭集的补集，故 $f^{-1}(V)$ 是开集。因此 $f$ 连续。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id="示例-examples"&gt;示例 (Examples)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实变函数：&lt;/strong&gt; $f: E^1 \to E^1$ (如 $x^n, e^x, \ln x, \sin x, \cos x, \dots$) 都是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多元函数：&lt;/strong&gt; $f: E^1 \times E^1 \to E^1$ (如 $x+y, xy, x/y (y \ne 0), \dots$) 都是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="积空间映射的连续性"&gt;积空间映射的连续性
&lt;/h3&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;命题&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $f: X \to Y_1 \times Y_2$ 的分量映射为 $f_1: X \to Y_1$ 和 $f_2: X \to Y_2$，即 $f(x) = (f_1(x), f_2(x))$。&lt;/p&gt;
&lt;p&gt;则 $f$ 是&lt;strong&gt;连续的&lt;/strong&gt; $\iff$ &lt;strong&gt;$f_1$ 和 $f_2$ 都是连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;&lt;strong&gt;证明 &amp;ldquo;$\implies$&amp;rdquo; ( $f$ 连续 $\implies f_1, f_2$ 连续)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;投影映射 $\pi_1: Y_1 \times Y_2 \to Y_1$ 和 $\pi_2: Y_1 \times Y_2 \to Y_2$ 都是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分量映射可表示为复合：$f_1 = \pi_1 \circ f$ 和 $f_2 = \pi_2 \circ f$。&lt;/p&gt;
&lt;p&gt;因为&lt;a class="link" href="#mix" &gt;连续映射的复合是连续的&lt;/a&gt;，故 $f_1$ 和 $f_2$ 都是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明 &amp;ldquo;$\impliedby$&amp;rdquo; ( $f_1, f_2$ 连续 $\implies f$ 连续)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设 $\mathcal{B} = \{ U_1 \times U_2 \mid U_1 \in \mathcal{T}_{Y_1}, U_2 \in \mathcal{T}_{Y_2} \}$ 是积空间 $Y_1 \times Y_2$ 的一个基。&lt;/p&gt;
&lt;p&gt;我们只需证明对于 $\forall U_1 \times U_2 \in \mathcal{B}$，其原像 $f^{-1}(U_1 \times U_2)$ 在 $X$ 中是开集。&lt;/p&gt;
&lt;p&gt;原像可分解为：
&lt;/p&gt;
$$f^{-1}(U_1 \times U_2) = f_1^{-1}(U_1) \cap f_2^{-1}(U_2)$$&lt;p&gt;因为 $f_1$ 连续且 $U_1$ 开，所以 $f_1^{-1}(U_1)$ 是 $X$ 中的&lt;strong&gt;开集&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为 $f_2$ 连续且 $U_2$ 开，所以 $f_2^{-1}(U_2)$ 是 $X$ 中的&lt;strong&gt;开集&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;两个开集的交集 $f_1^{-1}(U_1) \cap f_2^{-1}(U_2)$ 仍然是 $X$ 中的&lt;strong&gt;开集&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据&lt;a class="link" href="#basis-cri" &gt;基元素判别引理&lt;/a&gt;， $f$ 是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，$f$ 连续 $\iff f_1, f_2$ 连续。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id="粘合引理-the-pasting-lemma"&gt;粘合引理 (The Pasting Lemma)
&lt;/h3&gt;
&lt;div class="math-block math-block--theorem" id="pasting"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;粘合引理 (The Pasting Lemma)&lt;/strong&gt;&lt;a href="#pasting" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间，且 $A, B$ 是 $X$ 中的两个&lt;strong&gt;闭集&lt;/strong&gt;，满足 $A \cup B = X$。&lt;/p&gt;
&lt;p&gt;假设 $f: A \to Y$ 和 $g: B \to Y$ 是两个连续映射，且对于 $\forall x \in A \cap B$，$f(x) = g(x)$。&lt;/p&gt;
&lt;p&gt;则由此构造的映射 $h: X \to Y$ 是&lt;strong&gt;连续的&lt;/strong&gt;。&lt;/p&gt;
$$h(x) = \begin{cases} f(x) &amp; x \in A \\ g(x) &amp; x \in B \end{cases}$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;我们使用连续映射的&lt;a class="link" href="#close-cri" &gt;闭集判别法&lt;/a&gt;。设 $C$ 是 $Y$ 中的任意闭集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原像分解：&lt;/strong&gt; $h^{-1}(C)$ 可以分解为 $f^{-1}(C)$ 和 $g^{-1}(C)$ 的并集：
&lt;/p&gt;
$$h^{-1}(C) = f^{-1}(C) \cup g^{-1}(C)$$&lt;p&gt;&lt;strong&gt;验证 $f^{-1}(C)$ 是 $X$ 中的闭集：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 $f: A \to Y$ 连续，所以 $f^{-1}(C)$ 是&lt;strong&gt;子空间 $A$&lt;/strong&gt; 中的闭集。&lt;/li&gt;
&lt;li&gt;根据子空间拓扑定义，存在 $X$ 中的闭集 $D_1$，使得 $f^{-1}(C) = D_1 \cap A$。&lt;/li&gt;
&lt;li&gt;由于 $D_1$ 是 $X$ 中的闭集，且 $A$ 是命题条件给定的 $X$ 中的闭集，故 $f^{-1}(C)$ 是两个 $X$ 中闭集的交集，因此是 $X$ 中的&lt;strong&gt;闭集&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;验证 $g^{-1}(C)$ 是 $X$ 中的闭集：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同理，因为 $g: B \to Y$ 连续，且 $B$ 是 $X$ 中的闭集，所以 $g^{-1}(C)$ 在 $X$ 中是&lt;strong&gt;闭集&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$h^{-1}(C)$ 是 $X$ 中两个闭集的并集 $f^{-1}(C) \cup g^{-1}(C)$。&lt;/li&gt;
&lt;li&gt;因此 $h^{-1}(C)$ 是 $X$ 中的&lt;strong&gt;闭集&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;故 $h$ 是连续的。&lt;/li&gt;
&lt;/ul&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="同胚"&gt;同胚
&lt;/h2&gt;
&lt;div class="math-block math-block--definition" id="homeo"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition1.3.2 同胚映射&lt;/strong&gt;&lt;a href="#homeo" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X, Y$ 是拓扑空间 (topol. spaces)，映射 $f: X \rightarrow Y$ 是一个双射 (bijection)，其逆映射为 $f^{-1}: Y \rightarrow X$。&lt;/p&gt;
&lt;p&gt;如果 $f$ 和 $f^{-1}$ &lt;strong&gt;都是连续的&lt;/strong&gt; (continuous)，则称 $f$ 是一个&lt;strong&gt;同胚&lt;/strong&gt; (homeomorphism)。&lt;/p&gt;
&lt;p&gt;如果 $X$ 和 $Y$ 之间存在一个同胚 (homeomorphism)，则称 $X$ 和 $Y$ &lt;strong&gt;同胚&lt;/strong&gt; (homeomorphic)，记作 $X \cong Y$。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(i) $\forall U$ 是 $X$ 中的开集 (open in $X$)，则 $f(U)$ 是 $Y$ 中的开集 (open in $Y$)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 因为 $f^{-1}: Y \rightarrow X$ 是连续的 (continuous)，所以 $(f^{-1})^{-1}(U)$ 是 $Y$ 中的开集 (open in $Y$)，即 $f(U)$ 是 $Y$ 中的开集 (open in $Y$)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(ii) $\forall V$ 是 $Y$ 中的开集 (open in $Y$)，则 $f^{-1}(V)$ 在 $X$ 中是开集 (open in $X$)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt; 因为 $f: X \rightarrow Y$ 是连续的 (continuous)，所以 $f^{-1}(V)$ 在 $X$ 中是开集 (open in $X$)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="同胚的性质"&gt;同胚的性质
&lt;/h3&gt;&lt;p&gt;设 $f: X \stackrel{\cong}{\longrightarrow} Y$ 是一个同胚。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f$ 是 $X$ 中的点和 $Y$ 中的点之间的双射 (bijection)。&lt;/li&gt;
&lt;li&gt;$f$ 诱导了 $X$ 中的开集和 $Y$ 中的开集之间的双射。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Remark：&lt;/strong&gt;
“$\cong$” 是拓扑空间 (topol. spaces) 之间的一个&lt;strong&gt;等价关系&lt;/strong&gt; (equivalence relation)。&lt;/p&gt;
&lt;p&gt;(i) $X \cong X$ (自反性)。&lt;/p&gt;
&lt;p&gt;(ii) $X \cong Y \Rightarrow Y \cong X$ (对称性)。&lt;/p&gt;
&lt;p&gt;(iii) $X \cong Y, Y \cong Z \Rightarrow X \cong Z$ (传递性)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Remark：&lt;/strong&gt; 同胚$f$是开映射并且也是闭映射。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开映射：将开集映到开集；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;闭映射：将闭集映到闭集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;命题&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X, Y$ 是拓扑空间 (topol. space)。&lt;/p&gt;
&lt;p&gt;$f: X \rightarrow Y$ 是一个同胚 (homeomorphism)
&lt;/p&gt;
$$\iff$$&lt;p&gt;
$f$ 是双射 (bijective)，连续 (continuous) 且是&lt;strong&gt;开映射&lt;/strong&gt; (open)
&lt;/p&gt;
$$\iff$$&lt;p&gt;
$f$ 是双射 (bijective)，连续 (continuous) 且是&lt;strong&gt;闭映射&lt;/strong&gt; (closed)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(注：)&lt;/strong&gt;
&lt;/p&gt;
$$f \text{ 是同胚} \iff \begin{cases} f \text{ 是双射} \\ f \text{ 连续} \\ f^{-1} \text{ 连续} \end{cases}$$&lt;p&gt;
&lt;/p&gt;
$$f \text{ 是双射、连续} \text{ 且是开映射}$$&lt;p&gt;
&lt;/p&gt;
$$f \text{ 是双射、连续} \text{ 且是闭映射}$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;&lt;strong&gt;$f$ 是同胚 $\Rightarrow f$ 是双射、连续且开映射：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设 $f$ 是同胚。则 $f$ 是双射且连续。
要证 $f$ 是开映射。
$\forall$ 开集 $U$ 在 $X$ 中，因为 $f^{-1}: Y \rightarrow X$ 是连续的，所以 $(f^{-1})^{-1}(U)$ (即 $f(U)$) 在 $Y$ 中是开集。因此 $f$ 是一个开映射 (open map)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$f$ 是双射、连续且开映射 $\Rightarrow f$ 是同胚：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设 $f$ 是双射、连续且开映射。
要证 $f$ 是同胚，只需证 $f^{-1}: Y \rightarrow X$ 连续。
$\forall$ 开集 $U$ 在 $X$ 中，因为 $f: X \rightarrow Y$ 是开映射，所以 $f(U)$ 在 $Y$ 中是开集。
又 $f(U) = (f^{-1})^{-1}(U)$。
根据连续性的定义， $f^{-1}: Y \rightarrow X$ 是连续的。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Hausdorff性质拓扑不变&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
如果 $f: X \rightarrow Y$ 是一个同胚 (Homeomorphism)，且 $X$ 是 Hausdorff 空间，那么 $Y$ 也是 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;。
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;$\forall y_1, y_2 \in Y$，且 $y_1 \neq y_2$。
由于 $f$ 是双射，则 $f^{-1}(y_1) \neq f^{-1}(y_2)$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设 $x_1 = f^{-1}(y_1)$， $x_2 = f^{-1}(y_2)$。由于 $X$ 是 Hausdorff 空间，存在 $x_1$ 和 $x_2$ 在 $X$ 中的不相交开邻域 $U_1$ 和 $U_2$。&lt;/li&gt;
&lt;li&gt;因为 $f$ 是同胚，所以 $f$ 是开映射。&lt;/li&gt;
&lt;li&gt;$V_1 = f(U_1)$ 和 $V_2 = f(U_2)$ 是 $Y$ 中的开集。&lt;/li&gt;
&lt;li&gt;$y_1 = f(x_1) \in f(U_1) = V_1$， $y_2 = f(x_2) \in f(U_2) = V_2$。&lt;/li&gt;
&lt;li&gt;由于 $U_1 \cap U_2 = \emptyset$，且 $f$ 是双射，所以 $V_1 \cap V_2 = f(U_1) \cap f(U_2) = f(U_1 \cap U_2) = f(\emptyset) = \emptyset$。&lt;/li&gt;
&lt;li&gt;因此 $y_1$ 和 $y_2$ 有不相交的开邻域 $V_1$ 和 $V_2$，故 $Y$ 是 Hausdorff 空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;拓扑性质 (topol. property)：&lt;/strong&gt; 拓扑空间的一个性质，如果在同胚下保持不变 (preserved by homeomorphisms)，则称该性质为&lt;strong&gt;拓扑性质&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="嵌入embedding"&gt;嵌入（Embedding）
&lt;/h3&gt;
&lt;div class="math-block math-block--definition" id="embedding"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition1.3.3 嵌入映射&lt;/strong&gt;&lt;a href="#embedding" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
拓扑空间 $X$ 在 $Y$ 中的一个&lt;strong&gt;嵌入&lt;/strong&gt; (embedding) 是一个连续映射 $f: X \rightarrow Y$，它将 $X$ &lt;strong&gt;同胚&lt;/strong&gt;地 (homeomorphically) 映射到 $Y$ 中的子空间 $f(X)$ 上。
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注记 (Rmk.)：&lt;/strong&gt; 嵌入映射是&lt;strong&gt;单射&lt;/strong&gt; (injective)。&lt;/p&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;嵌入的等价条件&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X, Y$ 是拓扑空间 (topol. spaces)。
$f: X \rightarrow Y$ 是一个&lt;strong&gt;嵌入&lt;/strong&gt; (embedding)
&lt;/p&gt;
$$\iff$$&lt;p&gt;
$f$ 是&lt;strong&gt;内射&lt;/strong&gt; (injective)，&lt;strong&gt;连续&lt;/strong&gt; (continuous) 且&lt;strong&gt;开映射&lt;/strong&gt; (open)
&lt;/p&gt;
$$\iff$$&lt;p&gt;
$f$ 是&lt;strong&gt;内射&lt;/strong&gt; (injective)，&lt;strong&gt;连续&lt;/strong&gt; (continuous) 且&lt;strong&gt;闭映射&lt;/strong&gt; (closed)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(注：)&lt;/strong&gt; 这里的“开映射”和“闭映射”是指 $f: X \rightarrow f(X)$（视 $f(X)$ 为 $Y$ 的子空间）是开映射或闭映射。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id="合痕-isotopy"&gt;合痕 (isotopy)
&lt;/h3&gt;
&lt;div class="math-block math-block--definition" id="isotopy"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 合痕 (isotopy)&lt;/strong&gt;&lt;a href="#isotopy" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $f_0, f_1: S^1 \rightarrow E^3$ 是两个嵌入 (embeddings)。
如果存在一个连续映射 $F: S^1 \times [0, 1] \rightarrow E^3$，满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$F(x, 0) = f_0(x)$&lt;/li&gt;
&lt;li&gt;$F(x, 1) = f_1(x)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;且对于每个 $t \in [0, 1]$，映射 $f_t = F(\cdot, t): S^1 \rightarrow E^3$ (其中 $x \mapsto F(x, t)$) 都是 $E^3$ 中的一个嵌入 (embedding)，则称 $f_0$ 和 $f_1$ 是&lt;strong&gt;同痕的&lt;/strong&gt; (isotopic)。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;例 (Eg.)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个平凡的圆嵌入 (未打结的圆) 和一个三叶结 (Trefoil Knot) &lt;strong&gt;不同痕&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;图示中描绘了两个不同的但&lt;strong&gt;同痕&lt;/strong&gt;的嵌入（一个平凡圆和另一个形状略有变化的平凡圆）。&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>内点、闭包、边界点</title><link>https://cxzhou.com/p/topol-3/</link><pubDate>Mon, 13 Oct 2025 20:00:00 +0800</pubDate><guid>https://cxzhou.com/p/topol-3/</guid><description>&lt;img src="https://cxzhou.com/p/topol-3/cover.jpg" alt="Featured image of post 内点、闭包、边界点" /&gt;&lt;p&gt;封面画师：&lt;a class="link" href="https://www.pixiv.net/artworks/104538476" target="_blank" rel="noopener"
&gt;リース＠ついった&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="内部闭包和边界interior-closure-and-boundary"&gt;内部、闭包和边界(Interior, Closure and Boundary)
&lt;/h2&gt;&lt;h3 id="内部和闭包-interiorclosure"&gt;内部和闭包 (Interior&amp;amp;Closure)
&lt;/h3&gt;
&lt;div class="math-block math-block--definition" id="int-cl"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 1.2.1 内部和闭包 &lt;/strong&gt;&lt;a href="#int-cl" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;（1）设 $X$ 是一个拓扑空间，$A \subset X$ 是一个子集。$A$ 的&lt;strong&gt;内部&lt;/strong&gt;，记为 $A^{\circ}$ 或 $\text{int}(A)$，是&lt;strong&gt;包含在 $A$ 中的所有开集的并集&lt;/strong&gt;。&lt;/p&gt;
$$A^{\circ}=\bigcup_{U~is~open, U\subset A}U$$&lt;p&gt;&lt;strong&gt;等价描述 (Lemma):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点 $y \in X$ 属于 $A^{\circ}$ 当且仅当存在一个开集 $U$，使得 $y \in U \subset A$。&lt;/p&gt;
&lt;p&gt;（2）设 $X$ 是一个拓扑空间，$A \subset X$ 是一个子集。$A$ 的&lt;strong&gt;闭包&lt;/strong&gt;，记为 $\overline{A}$ 或 $\text{cl}(A)$，是&lt;strong&gt;包含 $A$ 的所有闭集的交集&lt;/strong&gt;。&lt;/p&gt;
$$\overline{A}=\bigcap_{V~is~closed, A\subset V}V$$&lt;p&gt;&lt;strong&gt;等价描述 (Lemma):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点 $y \in X$ 属于 $\overline{A}$ 当且仅当 $y$ 的每一个邻域都与 $A$ 相交（即 $U \cap A \ne \emptyset$）。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;性质 (Prop.):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A^{\circ}$ 是包含在 $A$ 中的&lt;strong&gt;最大的开集&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$A^{\circ}$ 本身是一个&lt;strong&gt;开集&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$(A^{\circ})^{\circ}= A^{\circ}$ (内部的内部等于内部)。&lt;/li&gt;
&lt;li&gt;$A$ 是开集当且仅当 $A = A^{\circ}$。&lt;/li&gt;
&lt;li&gt;$\overline{A}$ 是包含 $A$ 的&lt;strong&gt;最小的闭集&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$\overline{A}$ 本身是一个&lt;strong&gt;闭集&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$\overline{\overline{A}} = \overline{A}$ (闭包的闭包等于闭包)。&lt;/li&gt;
&lt;li&gt;$A$ 是闭集当且仅当 $A = \overline{A}$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;极限点关系：&lt;/strong&gt; $\overline{A} = A \cup A'$，其中 $A'$ 是 $A$ 的所有&lt;strong&gt;极限点&lt;/strong&gt;（或聚点）的集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;一些有用的推论-1&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间，$A, B \subset X$ 是其子集。以下性质成立：&lt;/p&gt;
&lt;p&gt;(i) 如果 $U$ 在 $X$ 中是&lt;strong&gt;开集&lt;/strong&gt;，$U \subset A$，则 $U \subset A^{\circ}$。&lt;/p&gt;
&lt;p&gt;(ii) 如果 $V$ 在 $X$ 中是&lt;strong&gt;闭集&lt;/strong&gt;，$V \supset A$，则 $V \supset \overline{A}$。&lt;/p&gt;
&lt;p&gt;(iii) $A \subset B \implies A^{\circ} \subset B^{\circ}$。&lt;/p&gt;
&lt;p&gt;(iv) $A \subset B \implies \overline{A} \subset \overline{B}$。&lt;/p&gt;
&lt;p&gt;(v) $A$ 是&lt;strong&gt;开集&lt;/strong&gt; $\iff A = A^{\circ}$。&lt;/p&gt;
&lt;p&gt;(vi) $A$ 是&lt;strong&gt;闭集&lt;/strong&gt; $\iff A = \overline{A}$。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(iii) 的证明 (Pf.):&lt;/strong&gt;
&lt;/p&gt;
$$A^{\circ} \text{ 是开集, } A^{\circ} \subset A \subset B \xrightarrow{(\text{i})} A^{\circ} \subset B^{\circ}$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(iv) 的证明 (Pf.):&lt;/strong&gt;
&lt;/p&gt;
$$\overline{B} \text{ 是闭集, } \overline{B} \supset B \supset A \xrightarrow{(\text{ii})} \overline{B} \supset \overline{A}$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;(v) 的证明 (Pf.):&lt;/strong&gt;
&lt;/p&gt;
$$\text{"}\implies\text{"}: \text{Since } A \text{ is open, and } A \subset A \xrightarrow{(\text{i})} A \subset A^{\circ} \text{ (且 } A^{\circ} \subset A \text{ 恒成立)}$$&lt;p&gt; &lt;/p&gt;
$$\text{"}\impliedby\text{": } A^{\circ} \text{ is open, and } A = A^{\circ} \implies A \text{ is open. }\square$$&lt;/li&gt;
&lt;/ul&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id="remark"&gt;Remark
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;$A^{\circ}$是$A$中最大的开集。&lt;/li&gt;
&lt;li&gt;$\overline{A}$是包含$A$的最小的闭集。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="稠密集可分空间与内部闭包的等价引理"&gt;稠密集、可分空间与内部/闭包的等价引理
&lt;/h3&gt;
&lt;div class="math-block math-block--definition" id="dense"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 稠密集 (Dense Set)&lt;/strong&gt;&lt;a href="#dense" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
设 $A$ 是拓扑空间 $X$ 的一个子集。如果 $A$ 的&lt;strong&gt;闭包&lt;/strong&gt;等于整个空间 $X$，即 $\overline{A} = X$，则称 $A$ 是 $X$ 的一个&lt;strong&gt;稠密集&lt;/strong&gt;（dense set）。
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="sep-space"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 可分空间 (Separable Space)&lt;/strong&gt;&lt;a href="#sep-space" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
一个拓扑空间 $X$，如果它拥有一个&lt;strong&gt;可数的稠密集&lt;/strong&gt;（countable dense subset），则称 $X$ 是一个&lt;strong&gt;可分空间&lt;/strong&gt;（separable space）。
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;示例 (Eg.):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 $\mathbb{R}_{fc}$（有限补拓扑下的实数集）中，每一个&lt;strong&gt;无限子集&lt;/strong&gt; $A$ 都是稠密集，即 $\overline{A} = \mathbb{R}$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="内部与闭包的等价引理"&gt;内部与闭包的等价引理
&lt;/h3&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;引理&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间，$A \subset X$，$y \in X$。&lt;/p&gt;
&lt;p&gt;(i) $y \in A^{\circ} \iff$ 存在一个&lt;strong&gt;开集&lt;/strong&gt; $U$，使得 $y \in U \subset A$。&lt;/p&gt;
&lt;p&gt;(ii) $y \in \overline{A} \iff$ $y$ 的&lt;strong&gt;每一个邻域&lt;/strong&gt;都与 $A$ 相交。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;&lt;strong&gt;(i) $\implies$&lt;/strong&gt;：$y \in A^{\circ}$ 意味着 $y$ 属于包含在 $A$ 内的所有开集的并集，故 $y$ 必属于其中某个开集 $U$ 且 $U \subset A$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(i) $\impliedby$&lt;/strong&gt;：显然 (若 $y$ 被包含在 $A$ 内的开集 $U$ 包围，则 $y$ 属于包含在 $A$ 内的最大开集 $A^{\circ}$)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) $\implies$&lt;/strong&gt;：(反证法) 假设 $y \in \overline{A}$ 但存在邻域 $U$ 使得 $U \cap A = \emptyset$。则 $X-U$ 是一个包含 $A$ 的闭集，故 $\overline{A} \subset X-U$，与 $y \in \overline{A}$ 矛盾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(ii) $\impliedby$&lt;/strong&gt;：(反证法) 假设 $y \notin \overline{A}$。则存在一个包含 $A$ 的闭集 $V_0$ 且 $y \notin V_0$。令 $U = X-V_0$，则 $U$ 是 $y$ 的一个开邻域，且 $U \cap A = \emptyset$，与假设矛盾。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id="边界-boundary"&gt;边界 (Boundary)
&lt;/h3&gt;
&lt;div class="math-block math-block--definition" id="boundary"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 1.2.5&lt;/strong&gt;&lt;a href="#boundary" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间，$A \subset X$ 是一个子集。$A$ 的&lt;strong&gt;边界&lt;/strong&gt;，记为 $\partial A$，定义为 $A$ 的闭包与 $A$ 的内部的差集：&lt;/p&gt;
$$\partial A = \overline{A} - A^{\circ}$$&lt;p&gt;&lt;strong&gt;等价描述 (Lemma):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点 $y \in X$ 属于 $\partial A$ 当且仅当 $y$ 的&lt;strong&gt;任何邻域&lt;/strong&gt;都同时与 $A$ 和 $X-A$ 相交。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;命题&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间，且 $B \subset A \subset X$。令 $\overline{B}_A$ 和 ${B_A}^{\circ}$ 分别表示 $B$ 在&lt;strong&gt;子空间 $A$&lt;/strong&gt; 中的闭包和内部；令 $\overline{B}$ 和 $B^{\circ}$ 分别表示 $B$ 在&lt;strong&gt;全空间 $X$&lt;/strong&gt; 中的闭包和内部。则以下关系成立：&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;子空间闭包与全空间闭包的关系：&lt;/strong&gt;
&lt;/p&gt;
$$\overline{B}_A = \overline{B} \cap A$$&lt;p&gt;(2) &lt;strong&gt;子空间内部与全空间闭包的关系：&lt;/strong&gt;
&lt;/p&gt;
$${B_A}^{\circ} = A - \overline{(A-B)}$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;(1) 证明 $\overline{B}_A = \overline{B} \cap A$&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\subset$&amp;quot;：&lt;/p&gt;
&lt;p&gt;$\forall x \in \overline{B}_A$，则 $x \in A$。取 $X$ 中 $x$ 的任意邻域 $U$。$U \cap A$ 是 $x$ 在 $A$ 中的邻域。因 $x \in \overline{B}_A$，故 $(U \cap A) \cap B \ne \emptyset$。因 $B \subset A$，所以 $U \cap B \ne \emptyset$。故 $x \in \overline{B}$。因此 $x \in \overline{B} \cap A$。&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\supset$&amp;quot;：&lt;/p&gt;
&lt;p&gt;$\forall x \in \overline{B} \cap A$。取 $x$ 在 $A$ 中的任意邻域 $U_A = U \cap A$ ($U$ 在 $X$ 中开)。因 $x \in \overline{B}$，故 $U \cap B \ne \emptyset$。因 $B \subset A$，故 $U_A \cap B = (U \cap A) \cap B = U \cap B \ne \emptyset$。因此 $x \in \overline{B}_A$。&lt;/p&gt;
&lt;p&gt;(2) 证明 ${B_A}^{\circ} = A - \overline{(A-B)}$&lt;/p&gt;
&lt;p&gt;证明 (Pf.):&lt;/p&gt;
&lt;p&gt;利用补集关系：${B_A}^{\circ} = A - \overline{(A-B)}_A$。应用结论 (1)：$\overline{(A-B)}_A = \overline{(A-B)} \cap A$。故 ${B_A}^{\circ} = A - (\overline{(A-B)} \cap A)$。根据集合论， $A - (C \cap A) = A - C$。最终 ${B_A}^{\circ} = A - \overline{(A-B)}$。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;提醒 (Remark)：&lt;/strong&gt; &lt;strong&gt;子空间内部与全空间内部的关系不一定成立&lt;/strong&gt;，即 ${B_A}^{\circ} \ne B^{\circ} \cap A$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反例 (Counterexample):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$X = \mathbb{R}_{std}, A = B = \mathbb{Q}$。&lt;/li&gt;
&lt;li&gt;${B_A}^{\circ} = \mathbb{Q}$。&lt;/li&gt;
&lt;li&gt;$B^{\circ} \cap A = \dot{\mathbb{Q}} \cap \mathbb{Q} = \emptyset \cap \mathbb{Q} = \emptyset$。&lt;/li&gt;
&lt;li&gt;故 ${B_A}^{\circ} \ne B^{\circ} \cap A$。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;一些有用的推论-2&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间，$A, B \subset X$。则以下恒等式和包含关系成立：&lt;/p&gt;
&lt;p&gt;(i) &lt;strong&gt;补集的内部&lt;/strong&gt; (Interior of the complement):
&lt;/p&gt;
$$\text{int}(X-A) = X - \overline{A}$$&lt;p&gt;
&lt;/p&gt;
$${(X-A)}^{\circ} = X - \overline{A}$$&lt;p&gt;(ii) &lt;strong&gt;补集的闭包&lt;/strong&gt; (Closure of the complement):
&lt;/p&gt;
$$\overline{X-A} = X - A^{\circ}$$&lt;p&gt;(iii) &lt;strong&gt;内部的交集&lt;/strong&gt; (Intersection of interiors):
&lt;/p&gt;
$$A^{\circ} \cap B^{\circ} = {(A \cap B)}^{\circ}}$$&lt;p&gt;(iv) &lt;strong&gt;内部的并集&lt;/strong&gt; (Union of interiors):
&lt;/p&gt;
$$A^{\circ} \cup B^{\circ} \subset \dot{A \cup B}$$&lt;p&gt;(v) &lt;strong&gt;闭包的交集&lt;/strong&gt; (Intersection of closures):
&lt;/p&gt;
$$\overline{A} \cap \overline{B} \supset \overline{A \cap B}$$&lt;p&gt;(vi) &lt;strong&gt;闭包的并集&lt;/strong&gt; (Union of closures):
&lt;/p&gt;
$$\overline{A \cup B} = \overline{A} \cup \overline{B}$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;(i) ${(X-A)}^{\circ} = X - \overline{A}$&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\subset$&amp;quot;：
$\forall x \in {(X-A)}^{\circ}$ (即 $x \in (X-A)^\circ$)，则存在 $x$ 的邻域 $U$，使得 $x \in U \subset X-A$。&lt;/p&gt;
&lt;p&gt;因此 $U \cap A = \emptyset$。&lt;/p&gt;
&lt;p&gt;根据内部/闭包的等价引理 (previous lemma: $y \in \overline{A} \iff$ 任何邻域交 $A$ 不为空)，$x$ 不属于 $\overline{A}$，即 $x \in X - \overline{A}$。&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\supset$&amp;quot;：&lt;/p&gt;
&lt;p&gt;$\forall x \in X - \overline{A}$。因为 $\overline{A}$ 是闭集，所以 $X - \overline{A}$ 是开集。&lt;/p&gt;
&lt;p&gt;且 $X - \overline{A} \subset X-A$。&lt;/p&gt;
&lt;p&gt;根据内部的定义（${(X-A)}^{\circ}$ 是包含在 $X-A$ 中的最大的开集），$X - \overline{A}$ 必须包含在 ${(X-A)}^{\circ}$ 中。&lt;/p&gt;
&lt;p&gt;因此 $X - \overline{A} \subset {(X-A)}^{\circ}$。&lt;/p&gt;
&lt;p&gt;(iii) $A^{\circ} \cap B^{\circ} = {(A \cap B)}^{\circ}}$&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\subset$&amp;quot;：
$\forall x \in A^{\circ} \cap B^{\circ}$。存在 $x$ 的邻域 $U_1$ 和 $U_2$，使得 $x \in U_1 \subset A$ 且 $x \in U_2 \subset B$。&lt;/p&gt;
&lt;p&gt;因此 $x \in U_1 \cap U_2 \subset A \cap B$。&lt;/p&gt;
&lt;p&gt;由于 $U_1$ 和 $U_2$ 都是开集，它们的交集 $U_1 \cap U_2$ 也是开集。&lt;/p&gt;
&lt;p&gt;根据内部的等价引理，$x \in {(A \cap B)}^{\circ}}$。&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\supset$&amp;quot;：&lt;/p&gt;
&lt;p&gt;因为 $A \cap B \subset A$，根据内部运算的单调性，${(A \cap B)}^{\circ} \subset A^{\circ}$。&lt;/p&gt;
&lt;p&gt;同理，因为 $A \cap B \subset B$，所以 ${(A \cap B)}^{\circ} \subset B^{\circ}$。&lt;/p&gt;
&lt;p&gt;因此，${(A \cap B)}^{\circ}$ 包含于它们的交集：${(A \cap B)}^{\circ} \subset A^{\circ} \cap B^{\circ}$。&lt;/p&gt;
&lt;p&gt;(iv) $A^{\circ} \cup B^{\circ} \subset {(A \cup B)}^{\circ}$&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\subset$&amp;quot;：&lt;/p&gt;
&lt;p&gt;因为 $A \subset A \cup B$，根据内部运算的单调性，$A^{\circ} \subset \dot{A \cup B}$。&lt;/p&gt;
&lt;p&gt;同理，因为 $B \subset A \cup B$，所以 $B^{\circ} \subset {(A \cup B)}^{\circ}$。&lt;/p&gt;
&lt;p&gt;因此，它们的并集 $A^{\circ} \cup B^{\circ}$ 包含于 ${(A \cup B)}^{\circ}$。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
&lt;strong&gt;对于 (iv)，&lt;/strong&gt; 等号不一定成立
&lt;strong&gt;对于 (v)，&lt;/strong&gt; 等号不一定成立。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反例 (Eg.)：&lt;/strong&gt; (说明 (iv) 中不取等号)&lt;/p&gt;
&lt;p&gt;设 $X = \mathbb{R}_{std}$（标准拓扑下的实数集）。令 $A=[-1,0]$，$B=(0,1]$。此时$A^{\circ}=(-1,0)$，$B^{\circ}=(0,1)$，因此$A^{\circ} \cup B^{\circ} = (-1,0) \cup (0,1)$。而$A\cup B=[-1,1]$，故 ${(A\cup B)}^{\circ}=(-1,1)$。显然$A^{\circ}\cup B^{\circ}\neq\dot{A\cup B}$，差了一个点 $\{0\}$。&lt;/p&gt;
&lt;p&gt;再令 $A=\mathbb{Q}$（有理数集），$B=\mathbb{R}-\mathbb{Q}$（无理数集）。在标准拓扑下，$A^{\circ}=\emptyset$ 且 $B^{\circ}=\emptyset$，因此 $A^{\circ} \cup B^{\circ}=\emptyset$。但$A\cup B=\mathbb{R}$，所以 ${(A\cup B)}^{\circ}=\mathbb{R}$，同样说明了$A^{\circ}\cup B^{\circ}\neq {(A\cup B)}^{\circ}$。&lt;/p&gt;
&lt;h2 id="极限点与闭包的关系"&gt;极限点与闭包的关系
&lt;/h2&gt;&lt;h3 id="极限点-limit-point"&gt;极限点 (Limit Point)
&lt;/h3&gt;
&lt;div class="math-block math-block--definition" id="limit-point"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 极限点&lt;/strong&gt;&lt;a href="#limit-point" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间，$A \subset X$ 是一个子集，$x \in X$。
$x$ 是 $A$ 的一个&lt;strong&gt;极限点&lt;/strong&gt;（limit point，或聚点），如果 $x$ 的&lt;strong&gt;每一个邻域&lt;/strong&gt;（nbhd）都与 $A$ 在一个&lt;strong&gt;不同于 $x$ 本身&lt;/strong&gt;的点上相交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;等价描述 (Equiv.):&lt;/strong&gt;&lt;/p&gt;
$$x \text{ 是 } A \text{ 的一个极限点 } \iff x \in \overline{A - \{x\}}.$$&lt;p&gt;&lt;strong&gt;符号表示:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们用 $A'$ 表示 $A$ 的所有极限点的集合。
则 $A' \subset \overline{A}$。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;示例 (Eg.):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 $E^1$ 中，$A = [0, 1) \cup \{2\}$，则 $2 \notin A'$。&lt;/li&gt;
&lt;li&gt;在 $E^1$ 中，$A = \mathbb{Q}$，则 $\forall x \in E^1$, $x \in A'$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="闭包与极限点集合的关系"&gt;闭包与极限点集合的关系
&lt;/h3&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;命题&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 是一个拓扑空间，$A \subset X$。则：
&lt;/p&gt;
$$\overline{A} = A \cup A'$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;证明 &amp;ldquo;$A \cup A' \subset \overline{A}$&amp;quot;：&lt;/p&gt;
&lt;p&gt;因为 $A \subset \overline{A}$ 且 $A' \subset \overline{A}$，所以 $A \cup A' \subset \overline{A}$。&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\overline{A} \subset A \cup A'$&amp;quot;：
$\forall x \in \overline{A}$，假设 $x \notin A$。根据闭包引理， $x$ 的任意邻域 $U$ 都与 $A$ 相交。因为 $x \notin A$，所以 $U \cap A$ 包含一个异于 $x$ 的点。故 $x$ 是 $A$ 的极限点，即 $x \in A'$。因此 $\overline{A} \subset A \cup A'$。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;推论 (Corollary): 闭集的充要条件&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;$A \subset X$ 是一个&lt;strong&gt;闭集&lt;/strong&gt; $\iff A' \subset A$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明思路:&lt;/strong&gt; $A$ 是闭集 $\iff A = \overline{A} \iff A = A \cup A' \iff A' \subset A$。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="积空间中集合的内部和闭包"&gt;积空间中集合的内部和闭包
&lt;/h2&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;命题&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $X$ 和 $Y$ 是两个拓扑空间，$A \subset X$，$B \subset Y$。则以下关系成立：&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;积集合的内部：&lt;/strong&gt;
&lt;/p&gt;
$$(A \times B)^\circ = A^{\circ} \times B^{\circ}$$&lt;p&gt;(2) &lt;strong&gt;积集合的闭包：&lt;/strong&gt;
&lt;/p&gt;
$$\overline{A \times B} = \overline{A} \times \overline{B}$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;(1) 积集合的内部：$(A \times B)^\circ = A^{\circ} \times B^{\circ}$&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\subset$&amp;quot;：&lt;/p&gt;
&lt;p&gt;$\forall (x, y) \in (A \times B)^\circ$，存在开集 $W \subset X \times Y$ 使得 $(x, y) \in W \subset A \times B$。存在基元素 $U \times V$ 使得 $(x, y) \in U \times V \subset W$。因此 $x \in U \subset A$ 且 $y \in V \subset B$。根据内部定义， $x \in A^{\circ}$ 且 $y \in B^{\circ}$，故 $(x, y) \in A^{\circ} \times B^{\circ}$。&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\supset$&amp;quot;：&lt;/p&gt;
&lt;p&gt;$\forall (x, y) \in A^{\circ} \times B^{\circ}$。则 $x \in A^{\circ}$ 且 $y \in B^{\circ}$。因为 $x \in A^{\circ}$，存在 $X$ 中的开集 $U$，使得 $x \in U \subset A$。因为 $y \in B^{\circ}$，存在 $Y$ 中的开集 $V$，使得 $y \in V \subset B$。考虑积集 $U \times V$。 $U \times V$ 是 $X \times Y$ 中的一个&lt;strong&gt;开集&lt;/strong&gt;。且 $(x, y) \in U \times V$。同时，由于 $U \subset A$ 且 $V \subset B$，故 $U \times V \subset A \times B$。因此，$(x, y)$ 被包含在 $A \times B$ 内的一个开集 $U \times V$ 中。根据内部的定义，$(x, y) \in (A \times B)^\circ$。&lt;/p&gt;
&lt;p&gt;(2) 积集合的闭包：$\overline{A \times B} = \overline{A} \times \overline{B}$&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\subset$&amp;quot;：(反证法)&lt;/p&gt;
&lt;p&gt;假设 $(x, y) \notin \overline{A} \times \overline{B}$，则假设 $x \notin \overline{A}$。存在 $x$ 的邻域 $U$ 使得 $U \cap A = \emptyset$。$U \times Y$ 是 $(x, y)$ 的邻域，且 $(U \times Y) \cap (A \times B) = (U \cap A) \times (Y \cap B) = \emptyset$。故 $(x, y) \notin \overline{A \times B}$，矛盾。&lt;/p&gt;
&lt;p&gt;证明 &amp;ldquo;$\supset$&amp;quot;：&lt;/p&gt;
&lt;p&gt;$\forall (x, y) \in \overline{A} \times \overline{B}$。设 $W$ 是 $(x, y)$ 的任意邻域，包含 $U \times V$ ($U, V$ 分别是 $x, y$ 的邻域)。因 $x \in \overline{A}, y \in \overline{B}$，故 $U \cap A \ne \emptyset$ 且 $V \cap B \ne \emptyset$。故 $W \cap (A \times B) \supset (U \times V) \cap (A \times B) = (U \cap A) \times (V \cap B) \ne \emptyset$。因此 $(x, y) \in \overline{A \times B}$。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>拓扑基</title><link>https://cxzhou.com/p/topol-2/</link><pubDate>Tue, 30 Sep 2025 12:31:00 +0800</pubDate><guid>https://cxzhou.com/p/topol-2/</guid><description>&lt;img src="https://cxzhou.com/p/topol-2/cover.png" alt="Featured image of post 拓扑基" /&gt;&lt;h2 id="拓扑基basis"&gt;拓扑基(Basis)
&lt;/h2&gt;
&lt;div class="math-block math-block--definition" id="basis"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;拓扑基&lt;/strong&gt;&lt;a href="#basis" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;对于一个非空集合 $X$，&lt;strong&gt;拓扑基&lt;/strong&gt;（或简称&lt;strong&gt;基&lt;/strong&gt;）$\mathcal{B}$ 是 $X$ 的幂集 $\mathcal{P}(X)$ 的一个子集，满足以下两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;覆盖条件（Covering Condition）&lt;/strong&gt;：
$\mathcal{B}$ 中的元素的并集必须覆盖整个集合 $X$。换句话说，对于 $X$ 中的任意一点 $x$，&lt;strong&gt;存在&lt;/strong&gt; $\mathcal{B}$ 中的一个集合 $B$，使得 $x \in B$。
&lt;/p&gt;
$$\bigcup_{B \in \mathcal{B}} B = X$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;交集条件（Intersection Condition）&lt;/strong&gt;：
如果 $B_1$ 和 $B_2$ 是 $\mathcal{B}$ 中的任意两个元素，并且它们的交集 $B_1 \cap B_2$ 不为空，那么对于交集中的任意一点 $x$，&lt;strong&gt;存在&lt;/strong&gt; $\mathcal{B}$ 中的第三个元素 $B_3$，使得 $x \in B_3$ 且 $B_3$ 包含于 $B_1 \cap B_2$。
&lt;/p&gt;
$$\forall B_1, B_2 \in \mathcal{B}, \forall x \in B_1 \cap B_2, \exists B_3 \in \mathcal{B} \text{ 使得 } x \in B_3 \subseteq B_1 \cap B_2$$&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果一个集合族$\mathcal{B}$满足&lt;a class="link" href="#basis" &gt;上述条件&lt;/a&gt;，则称其为一个&lt;strong&gt;基&lt;/strong&gt;，基$\mathcal{B}$生成的拓扑 $\mathcal{T}$ 定义为：&lt;/p&gt;
&lt;p&gt;$\mathcal{T}$ 中的一个子集 $U \subseteq X$ 是&lt;strong&gt;开集&lt;/strong&gt;，当且仅当它是 $\mathcal{B}$ 中一些元素的&lt;strong&gt;并集&lt;/strong&gt;。&lt;/p&gt;
$$\mathcal{T} = \left\{ \bigcup_{i \in I} B_i \mid B_i \in \mathcal{B}, I \text{ 为任意指标集} \right\}$$
&lt;div class="math-block math-block--theorem" id="lemma1.1.3"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;定理1.1.3&lt;/strong&gt;&lt;a href="#lemma1.1.3" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
设$X$为非空集合，$\mathcal{T}_{\mathcal{B}}$是由$X$上的一个拓扑基$\mathcal{B}$生成的拓扑，则$U\subset X$是这个拓扑空间中的开集当且仅当对任意$x\in U$，存在$B_x\in \mathcal{B}$，使得$x\in B_X \subset U$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;第一部分：证明 $1 \implies 2$&lt;/p&gt;
&lt;p&gt;（如果 $U$ 是开集，则对 $U$ 中的每一点，存在一个基元素包含该点并包含于 $U$。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设&lt;/strong&gt; $U \in \mathcal{T}_{\mathcal{B}}$，即 $U$ 是开集。&lt;/p&gt;
&lt;p&gt;根据基 $\mathcal{B}$ &lt;strong&gt;生成拓扑&lt;/strong&gt; $\mathcal{T}_{\mathcal{B}}$ 的定义，集合 $U$ 必须是 $\mathcal{B}$ 中一些元素的并集。
&lt;/p&gt;
$$\exists I \text{ (指标集) } \text{ 和 } \{B_i\}_{i \in I} \subset \mathcal{B} \text{ 使得 } U = \bigcup_{i \in I} B_i$$&lt;p&gt;取 $U$ 中任意一点 $x$，$x \in U$。&lt;/p&gt;
&lt;p&gt;由于 $x \in U$ 且 $U = \bigcup_{i \in I} B_i$，所以 $x$ 至少属于这个并集中的一个元素。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;存在&lt;/strong&gt;某个指标 $j \in I$，使得 $x \in B_j$。&lt;/p&gt;
&lt;p&gt;令 $B_x = B_j$。则 $B_x \in \mathcal{B}$（$B_j$ 取自 $\mathcal{B}$），且 $x \in B_x$。&lt;/p&gt;
&lt;p&gt;又因为 $B_x = B_j$ 是形成 $U$ 的并集中的一个元素，所以 $B_x \subset \bigcup_{i \in I} B_i = U$。&lt;/p&gt;
&lt;p&gt;综上，找到了一个 $B_x \in \mathcal{B}$ 使得 $x \in B_x \subset U$。&lt;/p&gt;
&lt;p&gt;由于 $x$ 是 $U$ 中的任意一点，结论成立。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;第二部分：证明 $2 \implies 1$&lt;/p&gt;
&lt;p&gt;（如果对 $U$ 中的每一点，都存在一个基元素包含该点并包含于 $U$，则 $U$ 是开集。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设&lt;/strong&gt; 对任意 $x \in U$，存在 $B_x \in \mathcal{B}$，使得 $x \in B_x \subset U$。&lt;/p&gt;
&lt;p&gt;证明 $U$ 是 $\mathcal{B}$ 中元素的并集。&lt;/p&gt;
&lt;p&gt;考虑所有满足上述条件的 $B_x$ 的集合族 $\{B_x\}_{x \in U}$，并考察它们的并集 $V$:
&lt;/p&gt;
$$V = \bigcup_{x \in U} B_x$$&lt;p&gt;要证 $U = V$。
- &lt;strong&gt;证明 $U \subset V$：&lt;/strong&gt;
对于 $U$ 中的任意一点 $y$，根据假设，存在 $B_y \in \mathcal{B}$ 使得 $y \in B_y$。
由于 $B_y$ 是并集 $V = \bigcup_{x \in U} B_x$ 中的一个元素，所以 $y \in V$。
因此，$U \subset V$。
- &lt;strong&gt;证明 $V \subset U$：&lt;/strong&gt;
对于并集 $V$ 中的任意一点 $z$，根据 $V$ 的定义，它必然属于某个 $B_{x'}$，其中 $x' \in U$。
即 $z \in B_{x'}$。
根据假设，每一个 $B_x$ 都满足 $B_x \subset U$。所以 $B_{x'} \subset U$。
因此，$z \in U$。
所以，$V \subset U$。&lt;/p&gt;
&lt;p&gt;由于 $U \subset V$ 且 $V \subset U$，所以 $U = V$。&lt;/p&gt;
&lt;p&gt;因此，$U = \bigcup_{x \in U} B_x$，即 $U$ 是 $\mathcal{B}$ 中一些元素的并集。&lt;/p&gt;
&lt;p&gt;根据基 $\mathcal{B}$ 生成的拓扑 $\mathcal{T}_{\mathcal{B}}$ 的定义，凡是 $\mathcal{B}$ 中元素的并集都是开集。&lt;/p&gt;
&lt;p&gt;所以 $U \in \mathcal{T}_{\mathcal{B}}$，即 $U$ 是开集。&lt;/p&gt;
&lt;p&gt;综上，条件 $1$ 和条件 $2$ 相互蕴含，因此它们等价，命题得证。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="lemma1.1.4"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;定理1.1.4&lt;/strong&gt;&lt;a href="#lemma1.1.4" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设$(X,\mathcal{T})$为一个拓扑空间，$\mathcal{B} \subset \mathcal{T}$，则$\mathcal{B}$是生成拓扑 $\mathcal{T}$的一个拓扑基当且仅当&lt;/p&gt;
$$(1) \quad X = \bigcup_{B\in\mathcal{B}}B \\
(2) \quad \text{对于 } U\in\mathcal{T} \text{ 和任意 } x\in U \text{，存在 } B_x\in \mathcal{B} \text{，使得 } x\in B_x \subset U.$$
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a class="link" href="#lemma1.1.3" &gt;定理1.1.3&lt;/a&gt;描述由$X$上的一个拓扑基生成的拓扑中开集的特征；&lt;/p&gt;
&lt;p&gt;&lt;a class="link" href="#lemma1.1.4" &gt;定理1.1.4&lt;/a&gt;，&lt;strong&gt;给定&lt;/strong&gt;一个开集族$\mathcal{B}$和一个拓扑$\mathcal{T}$，判定$\mathcal{B}$是$\mathcal{T}$的一个拓扑基.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注：验证拓扑基用&lt;a class="link" href="#basis" &gt;定义&lt;/a&gt;，分别验证&lt;strong&gt;覆盖条件&lt;/strong&gt;和&lt;strong&gt;交集条件&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="拓扑子空间subspace"&gt;拓扑子空间(subspace)
&lt;/h2&gt;&lt;p&gt;(又称作诱导拓扑，induced topology)&lt;/p&gt;
&lt;p&gt;引例：$(X, \mathcal{T})$是一个拓扑空间. $A \subset X$，$\mathcal{T}_A:=\{U \cap A | U \in \mathcal{T} \}$，$\mathcal{T}_A$是$A$上的拓扑.&lt;/p&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
$$(i) \phi \in \mathcal{T}_A, A=X \cap A \in \mathcal{T}_A \\
(ii) U_{\lambda} \cap A, \lambda \in \Lambda, U_{\lambda} \in \mathcal{T}. \\
\bigcup_{\lambda \in \Lambda}(U_{\lambda} \cap A) =(\bigcup_{\lambda \in \Lambda}U_{\lambda})\cap A \in \mathcal{T}_A, since \bigcup_{\lambda \in \Lambda}U_{\lambda} \in \mathcal{T}. \\
(iii) (U_1 \cap A) \cap (U_2 \cap A) = (U_1 \cap U_2) \cap A \in \mathcal{T}_A, U_1, U_2 \in \mathcal{T}.$$
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="subspace"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;拓扑子空间&lt;/strong&gt;&lt;a href="#subspace" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
称$\mathcal{T}_Y$为子空间拓扑，$(Y, \mathcal{T}_Y)$为拓扑空间$X$的子空间. 若$V \subset Y$，$V \in \mathcal{T}_Y$，则称$V$在$Y$中是开的.
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="subspace-gen"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;定理1.2.6&lt;/strong&gt;&lt;a href="#subspace-gen" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $\mathcal{B}$ 为拓扑空间 $(X, \mathcal{T})$ 的一个基，$Y \subset X$，则
&lt;/p&gt;
$$ \mathcal{B}_Y = \{ B \cap Y | B \in \mathcal{B} \} $$&lt;p&gt;
是$Y$上子空间拓扑$\mathcal{T}_Y$的一个基.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;$\forall$ 开集 $V \in Y$, $\exist$ 开集 $U \in X$, 使得 $V=U \cap Y$. $\mathcal{B}$ 为拓扑空间 $(X, \mathcal{T})$ 的一个基, $\exist \mathcal{B}_U \subset \mathcal{B}$, $s.t.$ $U = \bigcup_{B \in \mathcal{B}_U}$. 因此
&lt;/p&gt;
$$V = (\bigcup_{B \in \mathcal{B}_U} B) \cap Y = \bigcup_{B \in \mathcal{B}_U} (B \cap Y)$$&lt;p&gt;.&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;一个&lt;del&gt;有趣&lt;/del&gt;有用的Lemma：&lt;/p&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;子空间拓扑的传递性&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
设 $(X, \mathcal{T})$ 是一个拓扑空间，且 $B \subset A \subset X$。
设 $(A, \mathcal{T}_A)$ 和 $(B, \mathcal{T}_B)$ 是 $(X, \mathcal{T})$ 的子空间，并设 $(B, (\mathcal{T}_A)_B)$ 是 $(A, \mathcal{T}_A)$ 的子空间。
则 $(\mathcal{T}_A)_B = \mathcal{T}_B$。（即子空间拓扑具有传递性）。
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;$\subset$ $:$ ($\mathcal{T}_B$ 包含 $(\mathcal{T}_A)_B$)
任取 $U \in (\mathcal{T}_A)_B$，则存在一个 $A$ 中的开集 $U_1 \in \mathcal{T}_A$，使得 $U = U_1 \cap B$。
由于 $U_1 \in \mathcal{T}_A$ 是 $A$ 中的开集，故存在一个 $X$ 中的开集 $U_2 \in \mathcal{T}$，使得 $U_1 = U_2 \cap A$。
因此，
&lt;/p&gt;
$$U = (U_2 \cap A) \cap B$$&lt;p&gt;
由于 $B \subset A$，根据集合论的结合律和幂等律，有 $A \cap B = B$。
&lt;/p&gt;
$$U = U_2 \cap (A \cap B) = U_2 \cap B$$&lt;p&gt;
因为 $U_2 \in \mathcal{T}$ 是 $X$ 中的开集，所以 $U = U_2 \cap B$ 表明 $U$ 是 $B$ 中相对于 $X$ 拓扑 $\mathcal{T}$ 的开集。
因此，$U \in \mathcal{T}_B$。&lt;/p&gt;
&lt;p&gt;$\supset$ $:$ ( $(\mathcal{T}_A)_B$ 包含 $\mathcal{T}_B$)
任取 $U \in \mathcal{T}_B$，则存在一个 $X$ 中的开集 $U_2 \in \mathcal{T}$，使得 $U = U_2 \cap B$。
令 $U_1 = U_2 \cap A$。由于 $U_2 \in \mathcal{T}$，根据子空间拓扑的定义，我们有 $U_1 \in \mathcal{T}_A$。
现在，将 $U$ 表示为 $U_1$ 与 $B$ 的交集：
&lt;/p&gt;
$$U = U_2 \cap B$$&lt;p&gt;
再次利用 $B \subset A$ 推出 $B = A \cap B$：
&lt;/p&gt;
$$U = U_2 \cap (A \cap B) = (U_2 \cap A) \cap B$$&lt;p&gt;
代入 $U_1$：
&lt;/p&gt;
$$U = U_1 \cap B$$&lt;p&gt;
因为 $U_1 \in \mathcal{T}_A$，所以 $U = U_1 \cap B$ 表明 $U$ 是 $B$ 中相对于 $A$ 拓扑 $\mathcal{T}_A$ 的开集。
因此，$U \in (\mathcal{T}_A)_B$&lt;/p&gt;
&lt;p&gt;综合 (1) 和 (2)，得证 $(\mathcal{T}_A)_B = \mathcal{T}_B$。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="乘积空间product-space"&gt;乘积空间(Product space)
&lt;/h2&gt;&lt;p&gt;引例：设 $(X_1, \mathcal{T}_1)$ 和 $(X_2, \mathcal{T}_2)$ 是两个拓扑空间，
&lt;/p&gt;
$$ \mathcal{B} = \{ U \times V | U \in \mathcal{T}_1, V \in \mathcal{T}_2 \}.　$$&lt;p&gt;
则 $\mathcal{B}$ 是 $X_1 \times X_2$ 上的一个拓扑基.&lt;/p&gt;
&lt;p&gt;证明略，逐个验证&lt;a class="link" href="#basis" &gt;两个条件&lt;/a&gt;即可.&lt;/p&gt;
&lt;div class="math-block math-block--definition" id="product"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;乘积空间&lt;/strong&gt;&lt;a href="#product" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $(X_1, \mathcal{T}_1)$ 和 $(X_2, \mathcal{T}_2)$ 是两个拓扑空间, 称
&lt;/p&gt;
$$ \mathcal{B} = \{ U \times V | U \in \mathcal{T}_1, V \in \mathcal{T}_2 \}　$$&lt;p&gt;
所生成的$X_1 \times X_2$ 的拓扑 $\mathcal{T}$ 为&lt;strong&gt;乘积拓扑&lt;/strong&gt;，称 $(X_1 \times X_2, \mathcal{T})$ 为 $(X_1, \mathcal{T}_1)$ 和 $(X_2, \mathcal{T}_2)$ 的 &lt;strong&gt;乘积拓扑空间&lt;/strong&gt;，简称为$(X_1, \mathcal{T}_1)$ 和 $(X_2, \mathcal{T}_2)$的 &lt;strong&gt;积空间&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;$X$, $Y$ 是两个拓扑空间，$A \subset X$，$B \subset Y$，则$A \times B$在$X \times Y$上的诱导拓扑与$A \times B$的乘积拓扑等价。&lt;/p&gt;
&lt;h2 id="hausdoff"&gt;Hausdoff
&lt;/h2&gt;
&lt;div class="math-block math-block--definition" id="hausdoff"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Hausdoff性质&lt;/strong&gt;&lt;a href="#hausdoff" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $(X, \mathcal{T})$ 是一个拓扑空间。如果对于 $X$ 中的\textbf{任意两个不同的点} $x$ 和 $y$ (即 $x \neq y$)，都存在一个开集 $U$ 包含 $x$，以及一个开集 $V$ 包含 $y$，使得这两个开集\textbf{不相交}，则称 $(X, \mathcal{T})$ 是一个 Hausdorff 空间.&lt;/p&gt;
&lt;p&gt;符号表示为：
&lt;/p&gt;
$$
\forall x, y \in X, \quad x \neq y \implies \exists U \in \mathcal{T}, \exists V \in \mathcal{T} \text{ 使得 } \left\{
\begin{array}{l}
x \in U \\
y \in V \\
U \cap V = \emptyset
\end{array}
\right.
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;性质&lt;/strong&gt;：如果一个空间是Hausdoff的，则它的所有单点集都是闭的。&lt;/p&gt;
&lt;p&gt;一些例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\mathbb{R}$上，$\mathcal{B}=\{(n,n+1)|n\in\mathbb{Z}\}$生成的拓扑不是Hausdoff的.&lt;/li&gt;
&lt;li&gt;$\mathbb{R}_{fc}$不是Hausdoff, 但是其上的每一个单点集都是闭的.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="hausdoff-space"&gt;Hausdoff Space
&lt;/h3&gt;
&lt;div class="math-block math-block--definition" id="hausdoff-space"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Hausdoff Space&lt;/strong&gt;&lt;a href="#hausdoff-space" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
一个拓扑空间 $X$ 是 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;（或 $T_2$ 空间），如果对于任意两个不同的点 $a, b \in X$ ($a \ne b$)，都存在 $a$ 的一个邻域 $U_a$ 和 $b$ 的一个邻域 $U_b$，使得 $U_a$ 和 $U_b$ 不相交，即 $U_a \cap U_b = \emptyset$。
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Hausdorff 子空间&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
如果 $X$ 是一个 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;，且 $A \subset X$ 是 $X$ 的一个子空间 (subspace)，则 $A$ 也是 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;取 $A$ 中任意两个不等的点 $a, b \in A$，且 $a \ne b$。&lt;/p&gt;
&lt;p&gt;因为 $X$ 是 Hausdorff 空间，存在 $X$ 中 $a$ 的邻域 $U_a$ 和 $b$ 的邻域 $U_b$，使得 $U_a \cap U_b = \emptyset$ 。&lt;/p&gt;
&lt;p&gt;$U_a \cap A$ 是 $a$ 在 $A$ 中的一个邻域，$U_b \cap A$ 是 $b$ 在 $A$ 中的一个邻域。&lt;/p&gt;
&lt;p&gt;它们的交集为：&lt;/p&gt;
$$(U_a \cap A) \cap (U_b \cap A) = (U_a \cap U_b) \cap A = \emptyset \cap A = \emptyset$$&lt;p&gt;因此 $A$ 是 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Hausdorff 积空间&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
如果 $X$ 和 $Y$ 是两个 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;，则它们的积空间 $X \times Y$ 也是 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;取 $X \times Y$ 中任意两个不等的点 $(x_1, y_1), (x_2, y_2) \in X \times Y$ 。&lt;/p&gt;
&lt;p&gt;因为 $(x_1, y_1) \ne (x_2, y_2)$，所以 &lt;strong&gt;要么&lt;/strong&gt; $x_1 \ne x_2$，&lt;strong&gt;要么&lt;/strong&gt; $y_1 \ne y_2$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设&lt;/strong&gt; $x_1 \ne x_2$。&lt;/p&gt;
&lt;p&gt;因为 $X$ 是 Hausdorff 空间，存在 $x_1$ 的邻域 $U_{x_1}$ 和 $x_2$ 的邻域 $U_{x_2}$，使得 $U_{x_1} \cap U_{x_2} = \emptyset$。&lt;/p&gt;
&lt;p&gt;则 $U_{x_1} \times Y$ 是 $(x_1, y_1)$ 在 $X \times Y$ 中的一个邻域，$U_{x_2} \times Y$ 是 $(x_2, y_2)$ 在 $X \times Y$ 中的一个邻域。&lt;/p&gt;
&lt;p&gt;它们的交集为：&lt;/p&gt;
$$(U_{x_1} \times Y) \cap (U_{x_2} \times Y) = (U_{x_1} \cap U_{x_2}) \times Y = \emptyset \times Y = \emptyset$$&lt;p&gt;因此 $X \times Y$ 是 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;。&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;推论：&lt;/strong&gt; 欧氏空间 $E^n$ 的任何子空间都是 &lt;strong&gt;Hausdorff 空间&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>线性表</title><link>https://cxzhou.com/p/datastructure-2/</link><pubDate>Fri, 26 Sep 2025 23:23:00 +0800</pubDate><guid>https://cxzhou.com/p/datastructure-2/</guid><description>&lt;img src="https://cxzhou.com/p/datastructure-2/cover.jpg" alt="Featured image of post 线性表" /&gt;&lt;h2 id="线性表的概念"&gt;线性表的概念
&lt;/h2&gt;&lt;p&gt;线性表（Linear List）是一种最基本、最常用的数据结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：线性结构是一种有序的数据项集合 1。其中除了首尾数据项外，每个数据项都有&lt;strong&gt;唯一的前驱&lt;/strong&gt;和&lt;strong&gt;后继&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;首尾特性&lt;/strong&gt;：首数据项没有前驱，尾数据项没有后继。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线性&lt;/strong&gt;：新的数据项加入时，只会加入到原有某个数据项之前或之后，不会有分叉，也不会独立于原有数据集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;术语&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;表的大小（N）&lt;/strong&gt;：表中元素的个数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;首结点&lt;/strong&gt;：$A_0$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尾结点&lt;/strong&gt;：$A_{N−1}$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空表&lt;/strong&gt;：元素个数为零的表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位置（i）&lt;/strong&gt;：元素 $A_i$ 在表中的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="线性表的基本操作"&gt;线性表的基本操作
&lt;/h2&gt;&lt;p&gt;线性表的基本操作可分为四类：构造、读取属性、操纵数据和遍历。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;create()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;创建一个空的线性表。&lt;/td&gt;
&lt;td&gt;构造属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;length()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回线性表的长度。&lt;/td&gt;
&lt;td&gt;读取属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;search(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;搜索元素&lt;code&gt;x&lt;/code&gt; 的位置，不存在返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/td&gt;
&lt;td&gt;读取属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;visit(i)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;返回线性表中第 &lt;code&gt;i&lt;/code&gt; 个数据元素的值。&lt;/td&gt;
&lt;td&gt;读取属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;insert(i, x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在第 &lt;code&gt;i&lt;/code&gt; 个位置插入元素 &lt;code&gt;x&lt;/code&gt;。&lt;/td&gt;
&lt;td&gt;操纵数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;remove(i)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除第 &lt;code&gt;i&lt;/code&gt; 个位置的元素。&lt;/td&gt;
&lt;td&gt;操纵数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除线性表中的所有数据元素。&lt;/td&gt;
&lt;td&gt;操纵数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;traverse()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按序访问线性表的每一数据元素。&lt;/td&gt;
&lt;td&gt;遍历数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="线性表的顺序存储实现sequential-storage"&gt;线性表的顺序存储实现（Sequential Storage）
&lt;/h2&gt;&lt;h3 id="结构和原理"&gt;结构和原理
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原理&lt;/strong&gt;：线性表中的结点存放在存储器上&lt;strong&gt;一块连续的空间中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：结点的&lt;strong&gt;物理位置&lt;/strong&gt;和它的&lt;strong&gt;逻辑位置&lt;/strong&gt;是&lt;strong&gt;一致的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 实现&lt;/strong&gt;：在 Python 中，通常使用&lt;strong&gt;动态数组&lt;/strong&gt;（即 &lt;strong&gt;List&lt;/strong&gt;）来实现顺序存储结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个顺序存储结构需要保存三个变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;指向数组的指针&lt;/strong&gt;（或数组本身，例如 Python 中的 &lt;code&gt;list&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组规模&lt;/strong&gt;（容量，&lt;code&gt;capacity&lt;/code&gt;/&lt;code&gt;maxSize&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组中的元素个数&lt;/strong&gt;（表长，&lt;code&gt;size&lt;/code&gt;/&lt;code&gt;length&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="python-实现代码示例-linearlist"&gt;Python 实现代码示例 (&lt;code&gt;LinearList&lt;/code&gt;)
&lt;/h3&gt;&lt;p&gt;下面是顺序存储结构中一些关键操作的实现和复杂度分析。&lt;/p&gt;
&lt;h4 id="构造求长清空访问"&gt;构造、求长、清空、访问
&lt;/h4&gt;&lt;p&gt;这些操作在顺序表中效率很高。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinearList&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxSize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;maxSize&lt;/span&gt; &lt;span class="c1"&gt;# 最大容量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 用列表存储线性表的元素，这里用 None 填充初始容量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;# 记录线性表的长度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;返回线性表的长度。时间复杂度 O(1)&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;clear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;删除所有数据元素，只需将长度置为 0。时间复杂度 O(1)&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;返回第 i 个元素的值。时间复杂度 O(1)&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# 边界检查&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;263&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;Index out of range&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;在线性表中搜索 x，返回位置或 -1。时间复杂度 O(n)&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;遍历线性表，按序输出所有元素。时间复杂度 O(n)&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="插入操作-inserti-x"&gt;插入操作 (&lt;code&gt;insert(i, x)&lt;/code&gt;)
&lt;/h4&gt;&lt;p&gt;在顺序表中插入元素需要移动结点，效率较低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查是否需要&lt;strong&gt;扩容&lt;/strong&gt; (&lt;code&gt;double_space()&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;从尾部 &lt;code&gt;$a_{n-1}$&lt;/code&gt; 开始，依次将 &lt;code&gt;$a_{n-1}, \dots, a_i$&lt;/code&gt; 向后移动一位。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;i&lt;/code&gt; 位置放入新元素 &lt;code&gt;x&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;表长 &lt;code&gt;size&lt;/code&gt; 加 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;扩容策略&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用倍数扩容（例如扩大一倍）&lt;/strong&gt;：总时间复杂度为 $O(n)$，&lt;strong&gt;均摊时间复杂度为 $O(1)$&lt;/strong&gt;，性能显著优化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用常数 C 扩容&lt;/strong&gt;：总时间复杂度为 $O(n^2)$，均摊时间复杂度为 $O(n)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;double_space&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;扩大数组容量一倍 [cite: 189, 195]&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;new_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt; &lt;span class="c1"&gt;# 重新申请更大规模数组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;new_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;# 拷贝原有数据&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_data&lt;/span&gt; &lt;span class="c1"&gt;# 释放原有数组空间，使用新数组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;在第 i 个位置插入元素 x&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;double_space&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# i 的合法取值范围是 0 到 n&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 移动元素 (从后往前移动)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="c1"&gt;# 插入新元素 &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;Invalid index&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 时间复杂度：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 最好情况 O(1) (i=n, 尾部插入)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 最坏情况 O(n) (i=0, 头部插入) &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 平均情况 O(n) [cite: 301]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="删除操作-removei"&gt;删除操作 (&lt;code&gt;remove(i)&lt;/code&gt;)
&lt;/h4&gt;&lt;p&gt;删除操作同样需要移动结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 &lt;code&gt;$a_{i+1}, \dots, a_{n-1}$&lt;/code&gt; 依次向前移动一位。&lt;/li&gt;
&lt;li&gt;表长 &lt;code&gt;size&lt;/code&gt; 减 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;删除第 i 个位置的元素&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# i 的合法取值范围是 0 到 n-1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 移动元素 (从前往后移动)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 可选：将原最后一个元素位置置为 None (清理)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;Invalid index&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 时间复杂度：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 最好情况 O(1) (i=n-1, 尾部删除)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 最坏情况 O(n) (i=0, 头部删除)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 平均情况 O(n)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="顺序存储总结"&gt;顺序存储总结
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;strong&gt;定位访问的性能很好&lt;/strong&gt;，因为逻辑次序和物理次序一致。&lt;code&gt;visit(i)&lt;/code&gt;、&lt;code&gt;length()&lt;/code&gt;、&lt;code&gt;clear()&lt;/code&gt; 的时间复杂度都是 &lt;strong&gt;$O(1)$&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：在&lt;strong&gt;插入/删除&lt;/strong&gt;时需要移动大量数据，性能不太理想 (&lt;strong&gt;$O(n)$&lt;/strong&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：适合&lt;strong&gt;静态的&lt;/strong&gt;、&lt;strong&gt;经常做定位访问&lt;/strong&gt;的线性表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Python 关联&lt;/strong&gt;：Python 中 &lt;code&gt;list&lt;/code&gt; 的底层实现大致与顺序线性表相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="线性表的链接存储实现linked-storage"&gt;线性表的链接存储实现（Linked Storage）
&lt;/h2&gt;&lt;p&gt;链接存储通过指针来表示结点间的逻辑关系，&lt;strong&gt;结点的物理位置可能相邻也可能不相邻&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="单链表-singly-linked-list"&gt;单链表 (Singly Linked List)
&lt;/h3&gt;&lt;h4 id="单链表结构"&gt;单链表结构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;结点&lt;/strong&gt;：包含数据域和指向下一个结点的指针域 (&lt;code&gt;next&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头指针&lt;/strong&gt;：一个指向链表头结点的指针变量 (&lt;code&gt;head&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头结点&lt;/strong&gt;：通常在表头额外增加一个特殊结点（不属于线性表组成部分），目的是&lt;strong&gt;简化在表头位置上进行插入和删除的操作&lt;/strong&gt;，使之与在其它结点位置上的操作一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="python-结点和链表类"&gt;Python 结点和链表类
&lt;/h4&gt;&lt;p&gt;在 Python 中，通过&lt;strong&gt;引用&lt;/strong&gt;的特性实现类似 C 语言指针的效果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;定义链表结点&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LinkedList&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;构造函数：创建一个只有头结点的空链表&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 创建头结点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 头结点的 next 默认为 None，表示空表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="单链表插入操作-inserti-x"&gt;单链表插入操作 (&lt;code&gt;insert(i, x)&lt;/code&gt;)
&lt;/h4&gt;&lt;p&gt;插入操作不需要移动数据元素，只需修改两个指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到第 &lt;code&gt;i-1&lt;/code&gt; 个结点（即 &lt;code&gt;current&lt;/code&gt;）,需要 $O(i)$ 的时间。&lt;/li&gt;
&lt;li&gt;创建新结点 &lt;code&gt;new_node&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;新结点的 &lt;code&gt;next&lt;/code&gt; 指向 &lt;code&gt;current&lt;/code&gt; 的后继结点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;current&lt;/code&gt; 的 &lt;code&gt;next&lt;/code&gt; 指向新结点 &lt;code&gt;new_node&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;在第 i 个位置插入元素 x&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 边界检查&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;Index out of range&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="c1"&gt;# 从头结点开始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 找到要插入位置 i 的前一个节点（i-1）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 先武装自己：新结点的 next 指向 current.next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 再加入队伍：current 的 next 指向新结点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 时间复杂度：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 最好情况 O(1) (i=0, 头部插入, 找到头结点 O(1))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 最坏情况 O(n) (i=n, 尾部插入, 需遍历到倒数第二个结点)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 平均情况 O(n)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="单链表删除操作-removei"&gt;单链表删除操作 (&lt;code&gt;remove(i)&lt;/code&gt;)
&lt;/h4&gt;&lt;p&gt;删除操作同样只需修改一个指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到要删除结点 &lt;code&gt;$a_i$&lt;/code&gt; 的前驱结点 &lt;code&gt;$a_{i-1}$&lt;/code&gt;（即 &lt;code&gt;current&lt;/code&gt;），这需要 $O(i)$ 的时间。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;$a_{i-1}$&lt;/code&gt; 的 &lt;code&gt;next&lt;/code&gt; 指针直接指向 &lt;code&gt;$a_i$&lt;/code&gt; 的后继结点 &lt;code&gt;$a_{i+1}$&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;删除第 i 个位置的元素&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;Index out of range&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="c1"&gt;# 从头结点开始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 找到要删除位置 i 的前一个节点（i-1）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# current.next 指向 to_delete 的 next，即跳过 to_delete&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 时间复杂度：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 最好情况 O(1) (i=0, 头部删除)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 最坏情况 O(n) (i=n-1, 尾部删除)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 平均情况 O(n)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="访问和搜索操作-visiti-searchx"&gt;访问和搜索操作 (&lt;code&gt;visit(i)&lt;/code&gt;, &lt;code&gt;search(x)&lt;/code&gt;)
&lt;/h4&gt;&lt;p&gt;链表不支持随机存取，访问第 &lt;code&gt;i&lt;/code&gt; 个元素或搜索元素都需要从头开始遍历。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;访问线性表的第 i 个元素&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;Index out of range&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="c1"&gt;# 从首结点开始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 时间复杂度：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# O(n)，需要遍历 i 次。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;搜索元素 x 的位置 position&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="c1"&gt;# 从首结点开始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;position&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;position&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 时间复杂度：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# O(n)，最坏情况需要遍历整个链表。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="双链表doubly-linked-list"&gt;双链表（Doubly Linked List）
&lt;/h3&gt;&lt;h4 id="双链表结构"&gt;双链表结构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;结点&lt;/strong&gt;：包含数据域、指向&lt;strong&gt;直接前驱&lt;/strong&gt;的指针域 (&lt;code&gt;pre&lt;/code&gt;) 和指向&lt;strong&gt;直接后继&lt;/strong&gt;的指针域 (&lt;code&gt;next&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;头尾结点&lt;/strong&gt;：为了消除在表头、表尾插入删除的特殊处理，通常设置&lt;strong&gt;头结点&lt;/strong&gt;和&lt;strong&gt;尾结点&lt;/strong&gt;。
&lt;ul&gt;
&lt;li&gt;头结点的 &lt;code&gt;pre&lt;/code&gt; 为空，&lt;code&gt;next&lt;/code&gt; 指向首结点。&lt;/li&gt;
&lt;li&gt;尾结点的 &lt;code&gt;next&lt;/code&gt; 为空，&lt;code&gt;pre&lt;/code&gt; 指向最后一个结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="双链表插入操作-inserti-x"&gt;双链表插入操作 (&lt;code&gt;insert(i, x)&lt;/code&gt;)
&lt;/h4&gt;&lt;p&gt;在双链表中插入新结点 &lt;code&gt;new_node&lt;/code&gt; 在 &lt;code&gt;current&lt;/code&gt; 之后，需要修改四个指针（&lt;code&gt;new_node&lt;/code&gt; 的 &lt;code&gt;pre&lt;/code&gt;/&lt;code&gt;next&lt;/code&gt; 和前后结点的 &lt;code&gt;pre&lt;/code&gt;/&lt;code&gt;next&lt;/code&gt;）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 假设 Node 类已添加 self.prev = None 属性&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;在第 i 个位置插入元素 x (在 current 之后插入)&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# ... 边界检查 ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="c1"&gt;# 找到插入位置的前一个 node&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 1. 先武装自己：新节点的 pre/next 指向前后节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 2. 再加入队伍：调整前后节点的 pre/next 指针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="c1"&gt;# current 后一个节点的 pre 指向新节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="c1"&gt;# current 的 next 指向新节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 查找 current 仍需要 O(n)，但修改指针只需要 O(1)。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="双链表删除操作-removei"&gt;双链表删除操作 (&lt;code&gt;remove(i)&lt;/code&gt;)
&lt;/h4&gt;&lt;p&gt;删除操作只需要修改被删除结点的前一个和后一个结点的指针。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;删除第 i 个位置的元素 current&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# ... 边界检查 ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="c1"&gt;# 从首结点开始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c1"&gt;# 找到要删除的 node&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 将 current 的前驱和后继结点直接连接起来&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 查找 current 仍需要 O(n)，但删除操作（修改指针）只需要 O(1)。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="循环链表-circular-linked-list"&gt;循环链表 (Circular Linked List)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单循环链表&lt;/strong&gt;：末结点的 &lt;code&gt;next&lt;/code&gt; 指向首结点，形成一个环。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双循环链表&lt;/strong&gt;：末结点的 &lt;code&gt;next&lt;/code&gt; 指向头结点，首结点的 &lt;code&gt;pre&lt;/code&gt; 指向末结点，形成双向环。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：可以从任意一个结点开始，顺序向后访问到达任意结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="五-总结比较"&gt;五、 总结比较
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;th&gt;顺序存储 (如 Python List)&lt;/th&gt;
&lt;th&gt;单链表&lt;/th&gt;
&lt;th&gt;双链表&lt;/th&gt;
&lt;th&gt;循环链表&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;存储方式&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;连续存储&lt;/td&gt;
&lt;td&gt;离散存储 (通过指针连接)&lt;/td&gt;
&lt;td&gt;离散存储 (双向指针)&lt;/td&gt;
&lt;td&gt;离散存储 (末尾连回头部)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;访问性能&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$O(1)$ (随机存取，通过索引直接访问)&lt;/td&gt;
&lt;td&gt;$O(n)$ (需从头遍历)&lt;/td&gt;
&lt;td&gt;$O(n)$ (需从头遍历)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;插入/删除&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;$O(n)$ (需移动大量数据)&lt;/td&gt;
&lt;td&gt;$O(n)$ (需 $O(n)$ 查找前驱结点，$O(1)$ 修改指针)&lt;/td&gt;
&lt;td&gt;$O(n)$ (需 $O(n)$ 查找结点，$O(1)$ 修改指针)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;内存效率&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;好 (但可能因扩容产生开销)&lt;/td&gt;
&lt;td&gt;差 (需要额外的指针空间)&lt;/td&gt;
&lt;td&gt;最差 (需要两个指针空间)&lt;/td&gt;
&lt;td&gt;较差 (需要额外的指针空间)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;主要区别&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;适合&lt;strong&gt;静态&lt;/strong&gt;、经常做&lt;strong&gt;定位访问&lt;/strong&gt;的场景。&lt;/td&gt;
&lt;td&gt;只能&lt;strong&gt;单向&lt;/strong&gt;访问。&lt;/td&gt;
&lt;td&gt;可以&lt;strong&gt;双向&lt;/strong&gt;访问，删除操作更方便。&lt;/td&gt;
&lt;td&gt;可以从任何结点开始访问任一结点。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="六-线性表应用约瑟夫斯环问题"&gt;六、 线性表应用：约瑟夫斯环问题
&lt;/h2&gt;&lt;p&gt;约瑟夫斯环问题是一个经典的线性表应用，它模拟一群人围成一个圈，按规则淘汰，求最后剩下的人的位置。&lt;/p&gt;
&lt;h3 id="使用数组列表解决"&gt;使用数组/列表解决
&lt;/h3&gt;&lt;p&gt;使用 Python 的 &lt;code&gt;list&lt;/code&gt; 实现时，每次删除元素 &lt;code&gt;people.pop(index)&lt;/code&gt;，列表内部都需要移动其后的所有元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：$O(N^2)$ (每次淘汰都是 $O(N)$，总共淘汰 $N−1$ 次)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;josephus_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;使用 Python List 解决约瑟夫斯环问题&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;# [1, 2, ..., N]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;# 从第一个人开始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 计算下一个要淘汰的人的索引&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 淘汰该人&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 示例: josephus_list(7, 3) 返回 4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="使用单循环链表解决"&gt;使用单循环链表解决
&lt;/h3&gt;&lt;p&gt;使用单循环链表可以避免删除时移动大量数据的开销。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：$O(N\cdot M)$ (每次淘汰需要 $O(M)$ 步找到要删除的结点，总共淘汰 $N−1$ 次)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：尽管删除操作本身是 $O(1)$，但&lt;strong&gt;寻找&lt;/strong&gt;要删除的结点需要 $O(M)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;span class="lnt"&gt;35
&lt;/span&gt;&lt;span class="lnt"&gt;36
&lt;/span&gt;&lt;span class="lnt"&gt;37
&lt;/span&gt;&lt;span class="lnt"&gt;38
&lt;/span&gt;&lt;span class="lnt"&gt;39
&lt;/span&gt;&lt;span class="lnt"&gt;40
&lt;/span&gt;&lt;span class="lnt"&gt;41
&lt;/span&gt;&lt;span class="lnt"&gt;42
&lt;/span&gt;&lt;span class="lnt"&gt;43
&lt;/span&gt;&lt;span class="lnt"&gt;44
&lt;/span&gt;&lt;span class="lnt"&gt;45
&lt;/span&gt;&lt;span class="lnt"&gt;46
&lt;/span&gt;&lt;span class="lnt"&gt;47
&lt;/span&gt;&lt;span class="lnt"&gt;48
&lt;/span&gt;&lt;span class="lnt"&gt;49
&lt;/span&gt;&lt;span class="lnt"&gt;50
&lt;/span&gt;&lt;span class="lnt"&gt;51
&lt;/span&gt;&lt;span class="lnt"&gt;52
&lt;/span&gt;&lt;span class="lnt"&gt;53
&lt;/span&gt;&lt;span class="lnt"&gt;54
&lt;/span&gt;&lt;span class="lnt"&gt;55
&lt;/span&gt;&lt;span class="lnt"&gt;56
&lt;/span&gt;&lt;span class="lnt"&gt;57
&lt;/span&gt;&lt;span class="lnt"&gt;58
&lt;/span&gt;&lt;span class="lnt"&gt;59
&lt;/span&gt;&lt;span class="lnt"&gt;60
&lt;/span&gt;&lt;span class="lnt"&gt;61
&lt;/span&gt;&lt;span class="lnt"&gt;62
&lt;/span&gt;&lt;span class="lnt"&gt;63
&lt;/span&gt;&lt;span class="lnt"&gt;64
&lt;/span&gt;&lt;span class="lnt"&gt;65
&lt;/span&gt;&lt;span class="lnt"&gt;66
&lt;/span&gt;&lt;span class="lnt"&gt;67
&lt;/span&gt;&lt;span class="lnt"&gt;68
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;定义链表结点，用于约瑟夫斯环问题&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create_circle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s2"&gt; 创建 N 个结点的单循环链表。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s2"&gt; 编号从 1 到 N。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s2"&gt; &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 1. 创建第一个节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;744&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;745&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 2. 创建其他节点 (从 2 到 N)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;748&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 创建其他节点 [cite: 749]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;750&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 3. 形成循环链表：最后一个节点的 next 指向 head&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;751&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;josephus_linked_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="s2"&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s2"&gt; 使用单循环链表解决约瑟夫斯环问题。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s2"&gt; N 为人数，M 为淘汰间隔。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s2"&gt; 时间复杂度: O(N*M) [cite: 734]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="s2"&gt; &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;756&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cite&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;758&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;# M=1时，将按序淘汰 1, 2, ..., N-1，最后剩下 N。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;create_circle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 创建循环链表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;head&lt;/span&gt; &lt;span class="c1"&gt;# 记录当前结点，从编号 1 的结点开始&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt; &lt;span class="c1"&gt;# 记录前一个结点，用于删除操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c1"&gt;# 循环直到只剩一个结点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 1. 移动 M-1 步，找到要淘汰的节点的前一个节点 (prev)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 循环 M-1 次，使 current 停在要淘汰的节点 to_delete 上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 此时 current 为要淘汰的节点 to_delete&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# print(f&amp;#34;淘汰的节点:{current.value}&amp;#34;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 2. 淘汰节点：将 prev 的 next 指向 to_delete 的 next&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# to_delete = current&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="c1"&gt;# 删除该节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;# 3. 移动到下一个节点：新的 current 从 prev 的下一个结点（即原 to_delete 的 next）开始下一轮计数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="c1"&gt;# 移动到下一个节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="c1"&gt;# 返回最后剩下的节点的值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 示例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="c1"&gt;# 人数 [cite: 781]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="c1"&gt;# 每隔 M 个人淘汰一个 [cite: 782]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;last_person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;josephus_linked_list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# print(f&amp;#34;最后剩下的人在原始队伍中的位置是:{last_person}&amp;#34;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 期望输出结果为 4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>算法复杂度</title><link>https://cxzhou.com/p/datastructure-1/</link><pubDate>Sun, 21 Sep 2025 22:10:00 +0800</pubDate><guid>https://cxzhou.com/p/datastructure-1/</guid><description>&lt;img src="https://cxzhou.com/p/datastructure-1/cover.jpg" alt="Featured image of post 算法复杂度" /&gt;&lt;h2 id="什么是算法复杂度"&gt;什么是算法复杂度？
&lt;/h2&gt;&lt;p&gt;算法复杂度是衡量算法效率的重要指标，主要分析算法运行时所需的资源，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间&lt;/strong&gt;：程序运行所需的时间，即&lt;strong&gt;时间复杂度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间&lt;/strong&gt;：程序运行所需占用的内存空间，即&lt;strong&gt;空间复杂度&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在评估算法效率时，关键在于算法本身的优劣。一个高效的算法能在处理大规模数据时，显著减少运行时间。&lt;/p&gt;
&lt;h2 id="时间复杂度"&gt;时间复杂度
&lt;/h2&gt;&lt;h3 id="概念与大o表示法"&gt;概念与大O表示法
&lt;/h3&gt;&lt;p&gt;时间复杂度是一种抽象的度量，表示算法的&lt;strong&gt;运算量&lt;/strong&gt;与&lt;strong&gt;问题规模&lt;/strong&gt;之间的关系。它通常关注当问题规模变得非常大时，运行时间随问题规模增长的规律。&lt;/p&gt;
&lt;p&gt;我们使用&lt;strong&gt;大O表示法 (Big O Notation)&lt;/strong&gt; 来描述时间复杂度。它忽略具体的运行时间函数，只关注其&lt;strong&gt;数量级&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在正的常数 $c$ 和 $n_0$，使得当 $n\geq n_0$ 时有 $T(n)\leq cf(n)$，则 $T(n)$ 是 $O(f(n))$。&lt;/li&gt;
&lt;li&gt;计算大O表示法时，我们通常&lt;strong&gt;忽略系数和低次项&lt;/strong&gt;，只保留运行时间函数中的&lt;strong&gt;主导部分&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;大O表示法实例：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$T(n)=1000⟹O(1)$&lt;/li&gt;
&lt;li&gt;$T(n)=n+logn+1000⟹O(n)$&lt;/li&gt;
&lt;li&gt;$T(n)=5n^2+27n+1005⟹O(n^2)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见时间复杂度关系：&lt;/p&gt;
$$O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)\\
&lt;O(n^3)&lt;O(2^n)&lt;O(n)&lt;O(n^n)$$&lt;h3 id="复杂度计算规则"&gt;复杂度计算规则
&lt;/h3&gt;&lt;p&gt;计算时间复杂度通常遵循以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义标准操作&lt;/strong&gt;：选择一种或几种操作作为抽象的运算单位。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算操作次数&lt;/strong&gt;：将标准操作的执行次数表示为问题规模的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;取主项&lt;/strong&gt;：取出函数的主项，即为大O表示。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下是简化计算的常用规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;求和定理&lt;/strong&gt;：串行执行的程序段，总时间复杂度为各段中最大者。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;求积定理&lt;/strong&gt;：嵌套执行的程序段，总时间复杂度为各段时间复杂度之积。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环语句&lt;/strong&gt;：时间复杂度等于循环体的运行时间乘以循环次数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简化方法&lt;/strong&gt;：找出程序中运行时间最长的部分，它的时间复杂度就是整个程序的时间复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="例子最大连续子序列求和"&gt;例子：最大连续子序列求和
&lt;/h3&gt;&lt;p&gt;这个问题有多种算法，其时间复杂度差异巨大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：给定一个整数序列 A_1,A_2,&amp;hellip;,A_N，求其最大连续子序列的和。&lt;/p&gt;
&lt;h4 id="算法一穷举法-"&gt;算法一：穷举法 ($O(n^3)$)
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;maxSubsequenceSum_n3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;计算过程：&lt;/p&gt;
&lt;p&gt;我们以最内层的核心操作 &lt;code&gt;thisSum += a[k]&lt;/code&gt; 为标准操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最内层循环执行 &lt;code&gt;j−i+1&lt;/code&gt; 次。&lt;/li&gt;
&lt;li&gt;中间层循环执行 $\sum \_ j = i^{n−1}(j−i+1)$ 次。&lt;/li&gt;
&lt;li&gt;最外层循环执行 $\sum \_ i= 0^{n−1}\sum \_ j=i^{n−1}(j−i+1)$ 次。&lt;/li&gt;
&lt;li&gt;该求和表达式的结果约为 $\frac{n^3+3n^2+2n}{6}$。&lt;/li&gt;
&lt;li&gt;忽略系数和低次项，时间复杂度为 $O(n^3)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="算法二优化后的穷举法-"&gt;算法二：优化后的穷举法 ($O(n^2)$)
&lt;/h4&gt;&lt;p&gt;该算法移除了最内层的循环，通过累加当前子序列的和来优化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;maxSubsequenceSum_n2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;计算过程：&lt;/p&gt;
&lt;p&gt;我们以 &lt;code&gt;thisSum += a[j]&lt;/code&gt; 为标准操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内层循环的总执行次数为 $n+(n−1)+\cdots+1=\frac{n(n+1)}{2}$。&lt;/li&gt;
&lt;li&gt;该函数的主导项是 $\frac{n^2}{2}$。&lt;/li&gt;
&lt;li&gt;忽略系数，时间复杂度为 $O(n^2)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="算法三线性时间解法-on"&gt;算法三：线性时间解法 (O(n))
&lt;/h4&gt;&lt;p&gt;该算法基于一个洞察：如果一个从左端开始的子序列的和是负的，那么它不可能是最大连续子序列的一部分。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;maxSubsequenceSum_n&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;thisSum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;maxSum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;计算过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法只有一个循环，执行了 &lt;code&gt;n&lt;/code&gt; 次。&lt;/li&gt;
&lt;li&gt;循环内部的操作都是常量时间。&lt;/li&gt;
&lt;li&gt;整个算法的总运行时间与 &lt;code&gt;n&lt;/code&gt; 成正比。&lt;/li&gt;
&lt;li&gt;因此，时间复杂度为 $O(n)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="空间复杂度"&gt;空间复杂度
&lt;/h2&gt;&lt;h3 id="概念与空间换时间"&gt;概念与空间换时间
&lt;/h3&gt;&lt;p&gt;空间复杂度是算法在运行过程中使用的内存空间量，通常以大O表示法描述。它主要分析&lt;strong&gt;额外&lt;/strong&gt;占用的内存空间，不包括输入数据本身。&lt;/p&gt;
&lt;p&gt;在实际中，我们常常会使用“&lt;strong&gt;以空间换时间&lt;/strong&gt;”的策略，即通过增加内存使用来减少算法的运行时间。&lt;/p&gt;
&lt;h3 id="例子"&gt;例子
&lt;/h3&gt;&lt;h4 id="示例1o1"&gt;示例1：O(1)
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;algorithm_O1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;计算过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量 &lt;code&gt;a&lt;/code&gt; 占用固定空间。&lt;/li&gt;
&lt;li&gt;列表 &lt;code&gt;b&lt;/code&gt; 的大小固定为1000个元素，不随 &lt;code&gt;n&lt;/code&gt; 的变化而改变。&lt;/li&gt;
&lt;li&gt;算法所需的额外内存空间是一个常量，空间复杂度为 $O(1)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="示例2"&gt;示例2：$O(n)$
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;algorithm_On&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;nums&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;计算过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 &lt;code&gt;n &amp;gt; 10&lt;/code&gt; 时，创建了一个大小为 &lt;code&gt;n&lt;/code&gt; 的列表 &lt;code&gt;nums&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;列表所占用的内存空间与 &lt;code&gt;n&lt;/code&gt; 的值成正比。&lt;/li&gt;
&lt;li&gt;因此，空间复杂度为 $O(n)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="示例3"&gt;示例3：$O(n^2)$
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-Python" data-lang="Python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;algorithm_On2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;num_matrix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;计算过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代码创建了一个 $n\times n$ 的二维列表 &lt;code&gt;num_matrix&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;列表总共包含 $n\times n=n^2$ 个元素。&lt;/li&gt;
&lt;li&gt;占用的内存空间与 $n^2$ 成正比。&lt;/li&gt;
&lt;li&gt;因此，空间复杂度为 $O(n^2)$。&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>拓扑空间初步认识</title><link>https://cxzhou.com/p/topol-1/</link><pubDate>Fri, 29 Aug 2025 16:00:00 +0800</pubDate><guid>https://cxzhou.com/p/topol-1/</guid><description>&lt;img src="https://cxzhou.com/p/topol-1/cover.png" alt="Featured image of post 拓扑空间初步认识" /&gt;&lt;p&gt;笔记主要参考尤承业《基础拓扑学讲义》，为便于查找，所有定义、定理等编号与原书保持一致。&lt;/p&gt;
&lt;h2 id="拓扑空间"&gt;拓扑空间
&lt;/h2&gt;
&lt;div class="math-block math-block--definition" id="def-topol"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 1.1 拓扑空间 &lt;/strong&gt;&lt;a href="#def-topol" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设$X$是一非空集合. $X$的一个&lt;strong&gt;子集族&lt;/strong&gt;$\tau$称为$X$的一个&lt;strong&gt;拓扑&lt;/strong&gt;，如果它满足&lt;/p&gt;
&lt;p&gt;（1） $X$，$\emptyset$都包含在$ \tau $ 中；&lt;br&gt;
（2） $ \tau $ 中任意多个成员的并集仍在$ \tau $ 中；&lt;br&gt;
（3） $ \tau $ 中有限多个成员的交集仍在$ \tau $ 中.&lt;/p&gt;
&lt;p&gt;集合$X$和它的一个拓扑$ \tau $一起称为一个&lt;strong&gt;拓扑空间&lt;/strong&gt;，记作$(X, \tau)$. 称$\tau $中的成员为这个拓扑空间的&lt;strong&gt;开集&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;注&lt;/em&gt;：这里定义了拓扑空间中的&lt;strong&gt;开集&lt;/strong&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;定义&lt;a class="link" href="#def-topol" &gt;1.1&lt;/a&gt;中三个条件称为&lt;strong&gt;拓扑公理&lt;/strong&gt;. 其中（3）可等价为（3&amp;rsquo;）&lt;br&gt;
（3&amp;rsquo;）$\tau $中两个成员的交集仍在$\tau $ 中.&lt;/p&gt;
&lt;p&gt;证明如下：&lt;/p&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;“$\tau$ 对&lt;strong&gt;有限个&lt;/strong&gt;成员的交封闭” $\Leftrightarrow$ “$\tau$ 对&lt;strong&gt;任意两个&lt;/strong&gt;成员的交封闭”.&lt;/p&gt;
&lt;p&gt;$\Rightarrow$ 假设 $\tau$ 中任意有限个集合的交仍在 $\tau$ 中。则特别地，任取 $U, V \in \tau$，$U \cap V$ 也是有限交，故 $U \cap V \in \tau$.&lt;/p&gt;
&lt;p&gt;$\Leftarrow$ 反过来，假设 $\tau$ 中任意两个集合的交仍在 $\tau$ 中，即如果 $U, V \in \tau$，则 $U \cap V \in \tau$. 我们将证明 $\tau$ 对任意有限个集合的交闭.&lt;br&gt;
归纳地证明：&lt;/p&gt;
&lt;p&gt;当 $n = 2$ 时，结论显然成立（即假设中的条件）.&lt;/p&gt;
&lt;p&gt;假设任意 $n$ 个开集 $U_1, \dots, U_n \in \tau$ 有 $\bigcap_{i=1}^n U_i \in \tau$.&lt;br&gt;
考虑 $n+1$ 个开集 $U_1, \dots, U_n, U_{n+1} \in \tau$. 由归纳假设，$V := \bigcap_{i=1}^n U_i \in \tau$.&lt;br&gt;
再利用两个集合的交闭性，得到：&lt;br&gt;
&lt;/p&gt;
$$
\bigcap_{i=1}^{n+1} U_i = V \cap U_{n+1} \in \tau.
$$&lt;p&gt;
因此，对任意有限个开集，其交仍在 $\tau$ 中.&lt;/p&gt;
&lt;p&gt;由此，两者等价.&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;总结：给出集合的一个拓扑即规定哪些子集是开集，同时满足三条公理。&lt;/li&gt;
&lt;li&gt;一些例子：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;离散拓扑&lt;/strong&gt;: $2^X$，记作$\tau_t$；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;平凡拓扑&lt;/strong&gt;: $(X, \emptyset)$，记作$\tau_s$;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;余有限拓扑&lt;/strong&gt;: $X$是无穷集合，$\tau_f= \{ A^c \mid A是X的有限子集 \} \cup \{ \emptyset \} $；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;余可数拓扑&lt;/strong&gt;: $X$是不可数无穷集合，$\tau_c= \{ A^c \mid A是X的可数子集 \} \cup \{ \emptyset \} $；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;欧氏拓扑（标准拓扑）&lt;/strong&gt;: $\mathbf{R}$是全体实数集，$\tau_e= \{ U \mid U是若干个开区间的并集 \} $，“若干个”可以是无穷、有限、零，记作$\mathbf{E}^1=(\mathbf{R}, \tau_e)$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出&lt;strong&gt;余有限拓扑&lt;/strong&gt;的证明:&lt;/p&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;验证拓扑三公理.&lt;/p&gt;
&lt;p&gt;(1)
由定义可知$\emptyset\in\tau$ ；&lt;br&gt;
$X\in\tau$，因为 $X^c=\emptyset\in\tau$ .&lt;/p&gt;
&lt;p&gt;(2)
设 $U_{i, i\in I}\subseteq\tau$. 若存在 $i_0$ 使 $U_{i_0}=\emptyset$，不影响并集的开性，故不妨设对每个 $i$，$U_i\neq\emptyset$ 且 $X\setminus U_i$ 有限.
则
&lt;/p&gt;
$$
X\setminus \bigcup_{i\in I} U_i
= \bigcap_{i\in I} (X\setminus U_i).
$$&lt;p&gt;
右侧是（可能是无限个）有限集的交集. 任取 $j\in I$，有
&lt;/p&gt;
$$
\bigcap_{i\in I} (X\setminus U_i)\ \subseteq\ X\setminus U_j,
$$&lt;p&gt;
因此该交集是某个有限集的子集，从而也是有限集. 于是 $X\setminus \bigcup_{i\in I} U_i$ 有限，即 $\bigcup_{i\in I} U_i\in\tau$.&lt;/p&gt;
&lt;p&gt;(3)
取有限个 $U_1,\dots,U_n\in\tau$. 同理有
&lt;/p&gt;
$$
X\setminus \bigcap_{k=1}^n U_k
= \bigcup_{k=1}^n (X\setminus U_k),
$$&lt;p&gt;
右侧为有限个有限集的并，仍为有限集. 故 $\bigcap_{k=1}^n U_k\in\tau$.&lt;/p&gt;
&lt;p&gt;综上，$\tau$ 满足拓扑的三条公理，故为 $X$ 上的一个拓扑.&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id="度量拓扑"&gt;度量拓扑
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;回忆：&lt;/strong&gt; 度量空间三条性质（定义）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正定性&lt;/li&gt;
&lt;li&gt;对称性&lt;/li&gt;
&lt;li&gt;三角不等式&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math-block math-block--definition" id="circle"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;度量空间中的开球&lt;/strong&gt;&lt;a href="#circle" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设$(X, d)$是一个度量空间，$x_0 \in X，$\epsilon $是一正数，称$X$的子集
$$
B(x_0, \epsilon) := \{x_0\in X \mid d(x_0, x)&lt;\epsilon \}
$$&lt;/p&gt;
&lt;p&gt;为以$x_0$为心，$\epsilon$为半径的&lt;strong&gt;球形邻域&lt;/strong&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="circle-capcup"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;引理&lt;/strong&gt;&lt;a href="#circle-capcup" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
$(X, d)$的任意两个球形邻域的交集是若干个球形邻域的并集.
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;设$U=B(x_1, \epsilon_1)\cap B(x_2, \epsilon_2)$. $\forall x\in U$，则$\epsilon_i-d(x, x_i)&gt;0(i=1, 2)$. 记$\epsilon_x =min\{\epsilon_1-d(x, x_1), \epsilon_2-d(x, x_2)\}$，有$B(x, \epsilon_x)\subset U$. 于是
&lt;/p&gt;
$$
U=\bigcap_{x\in U}B(x, \epsilon_x).
$$
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;规定$X$的子集族$\tau_d=\{U \mid U是若干个开球的并集\}$.&lt;/p&gt;
&lt;div class="math-block math-block--theorem" id="measure-topol"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;命题1.1 度量空间上的拓扑&lt;/strong&gt;&lt;a href="#measure-topol" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
$\tau_d$是$X$上的一个拓扑.
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;验证三条公理.
（1），（2）均由定义可直接验证. 下证公理（3）.&lt;/p&gt;
&lt;p&gt;设$U_{\alpha}, U_{\beta} \in \tau_d$， &lt;/p&gt;
$$U_{\alpha}=\bigcup_{\alpha}B(x_{\alpha}, \epsilon_{\alpha}), U_{\beta}=\bigcup_{\beta}B(x_{\beta}, \epsilon_{\beta})$$&lt;p&gt;，则有&lt;/p&gt;
$$
\begin{align*}
U_{\alpha}\cap U_{\beta}=(\bigcup_{\alpha}B(x_{\alpha}, \epsilon_{\alpha}))\cap \bigcup_{\beta}B(x_{\beta}, \epsilon_{\beta}) \\
=\bigcup_{\alpha, \beta}(B(x_{\alpha}, \epsilon_{\alpha})\cap B(x_{\beta}, \epsilon_{\beta})).
\end{align*}
$$&lt;p&gt;由&lt;a class="link" href="#circle-capcup" &gt;引理&lt;/a&gt;, $B(x_{\alpha}, \epsilon_{\alpha})\cap B(x_{\beta}, \epsilon_{\beta}) \in \tau_d$,&lt;/p&gt;
&lt;p&gt;因此，$U_{\alpha}\cap U_{\beta} \in \tau_d$.&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id="拓扑大小的比较"&gt;拓扑“大小”的比较
&lt;/h3&gt;
&lt;div class="math-block math-block--definition" id="measure-topol"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;拓扑的比较&lt;/strong&gt;&lt;a href="#measure-topol" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;设 $(X, \mathcal{T}_1)$ 和 $(X, \mathcal{T}_2)$ 是定义在同一集合 $X$ 上的两个拓扑空间.&lt;/p&gt;
&lt;p&gt;如果 $\mathcal{T}_1$ 中的每一个开集都是 $\mathcal{T}_2$ 中的开集，则称拓扑 $\mathcal{T}_2$ &lt;strong&gt;比拓扑 $\mathcal{T}_1$ 更精细（finer）&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;用集合论的记号表示为：
&lt;/p&gt;
$$ \mathcal{T}_1 \subseteq \mathcal{T}_2 $$&lt;p&gt;在这种情况下，我们也称 $\mathcal{T}_1$ &lt;strong&gt;比 $\mathcal{T}_2$ 更粗糙（coarser）&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;会出现两个拓扑无法比较的情况.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="拓扑空间中的基本概念"&gt;拓扑空间中的基本概念
&lt;/h2&gt;&lt;p&gt;下述概念在实分析中均出现过，替换开集概念为拓扑空间中的&lt;a class="link" href="#def-topol" &gt;开集&lt;/a&gt;即可.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;闭集&lt;/li&gt;
&lt;li&gt;领域、内点和内部&lt;/li&gt;
&lt;li&gt;聚点和闭包&lt;/li&gt;
&lt;li&gt;序列收敛性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="重要性质"&gt;重要性质
&lt;/h3&gt;
&lt;div class="math-block math-block--theorem" id="close"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;命题1.2 拓扑空间中闭集的性质&lt;/strong&gt;&lt;a href="#close" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;ol&gt;
&lt;li&gt;$X$与$\emptyset$都是闭集；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任意多&lt;/strong&gt;个闭集的&lt;strong&gt;交集&lt;/strong&gt;都是闭集；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有限个&lt;/strong&gt;闭集的&lt;strong&gt;并集&lt;/strong&gt;是闭集.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="close"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;命题1.3&lt;/strong&gt;&lt;a href="#close" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;ol&gt;
&lt;li&gt;若$A \subset B$，则$A^{\circ} \subset B^{\circ}$；&lt;/li&gt;
&lt;li&gt;$A^{\circ}$是包含在$A$中所有开集的并集，是包含在$A$中的最大开集；&lt;/li&gt;
&lt;li&gt;$A^{\circ}=A \iff A$是开集；&lt;/li&gt;
&lt;li&gt;$(A\cap B)^{\circ}=A^{\circ}\cap B^{\circ}$&lt;/li&gt;
&lt;li&gt;$(A\cup B)^{\circ} \supset A^{\circ}\cup B^{\circ}$&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="c-product"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;笛卡尔积&lt;/strong&gt;&lt;a href="#c-product" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
$X_1 \times X_2 \times \cdots X_n:=\{(x_1, x_2, \cdots x_n) | x_i\in X_i\} $
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="c-distribute"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;笛卡尔积分配律&lt;/strong&gt;&lt;a href="#c-distribute" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
$$1. A\cup(\bigcap_{\lambda \in \Lambda}B_\lambda)= \bigcap_{\lambda \in \Lambda}(A\cup B_\lambda) \\
2. A\cap(\bigcup_{\lambda \in \Lambda}B_\lambda)= \bigcup_{\lambda \in \Lambda}(A\cap B_\lambda) \\
3. A\times(\bigcap_{\lambda \in \Lambda}B_\lambda)= \bigcap_{\lambda \in \Lambda}(A\times B_\lambda) \\
4. A\times(\bigcup_{\lambda \in \Lambda}B_\lambda)= \bigcup_{\lambda \in \Lambda}(A\times B_\lambda) \\
5. A\times(B_1 \backslash B_2)=(A\times B_1)\backslash (A\times B_2)
$$
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>IELTS备考-2</title><link>https://cxzhou.com/p/ielts-2/</link><pubDate>Wed, 16 Jul 2025 15:27:00 +0800</pubDate><guid>https://cxzhou.com/p/ielts-2/</guid><description>&lt;img src="https://cxzhou.com/p/ielts-2/cover.png" alt="Featured image of post IELTS备考-2" /&gt;&lt;h2 id="一表示增加或减少"&gt;一、表示增加或减少
&lt;/h2&gt;&lt;h3 id="表示增加increase"&gt;表示增加（Increase）
&lt;/h3&gt;&lt;p&gt;（1）动词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小幅增长：rise, grow, increase, climb&lt;br&gt;
e.g. The number of students grew slightly from 200 to 250.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显著增长：surge, jump, rocket, soar&lt;br&gt;
e.g. The population soared to 10 million in 2020.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）名词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小幅增长：a rise, an increase, a growth, an upward trend
e.g. There was a slight rise in the number of tourists.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显著增长：a surge, a jump, a boom
e.g. The city experienced a dramatic surge in population.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（3）副词 + 形容词（修饰增减幅度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小幅：slightly, marginally, gradually, modestly
e.g. The price of oil increased gradually over the year.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大幅：sharply, significantly, steeply, dramatically, considerably, substantially
e.g. The sales increased dramatically after the new product launch.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="表示减少decrease"&gt;表示减少（Decrease）
&lt;/h3&gt;&lt;p&gt;（1）动词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小幅下降：decrease, drop, fall, decline
e.g. The unemployment rate fell slightly in 2019.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显著下降：plunge, plummet, slump, collapse, dip
e.g. The stock prices plummeted after the financial crisis.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）名词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小幅下降：a fall, a decrease, a drop, a decline, a downward trend
e.g. There was a slight drop in the crime rate.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显著下降：a plunge, a slump, a collapse, a dip
e.g. The company suffered a dramatic slump in revenue.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（3）副词 + 形容词（修饰下降幅度）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小幅：slightly, marginally, gradually, modestly
e.g. The birth rate declined gradually over the decade.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大幅：sharply, significantly, steeply, dramatically, considerably, substantially
e.g. The number of visitors dropped sharply in winter.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="表示波动fluctuation"&gt;表示波动（Fluctuation）
&lt;/h3&gt;&lt;p&gt;（1）动词：fluctuate, vary, be volatile
e.g. The stock market fluctuated throughout the year.&lt;/p&gt;
&lt;p&gt;（2）名词：a fluctuation, a variation, volatility
e.g. There was a noticeable fluctuation in fuel prices.&lt;/p&gt;
&lt;p&gt;（3）副词 + 形容词：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;小幅波动：slightly, marginally → e.g. The data/statistics/figure fluctuated slightly over the period.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大幅波动：sharply, significantly, dramatically → e.g. The price showed a sharp fluctuation in March.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="表示稳定stability"&gt;表示稳定（Stability）
&lt;/h3&gt;&lt;p&gt;（1）动词：remain stable, stay constant, level off, reach a plateau&lt;/p&gt;
&lt;p&gt;e.g. The temperature remained stable throughout the summer.&lt;/p&gt;
&lt;p&gt;（2）名词：stability, a plateau&lt;/p&gt;
&lt;p&gt;e.g. The trend showed a period of stability after 2015.&lt;/p&gt;
&lt;p&gt;（3）副词 + 形容词：&lt;/p&gt;
&lt;p&gt;e.g. The inflation rate remained relatively stable.&lt;/p&gt;
&lt;h3 id="表示最高点和最低点"&gt;表示最高点和最低点
&lt;/h3&gt;&lt;p&gt;（1）最高点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动词：peak, reach a peak, hit the highest point
e.g. The sales peaked at 500 units in July.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;名词：a peak, the highest level&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e.g. The company’s revenue reached a peak in 2020.&lt;/p&gt;
&lt;p&gt;（2）最低点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动词：hit a low, bottom out, reach the lowest point
e.g. The number of visitors bottomed out in December.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;名词：a trough, the lowest level
e.g. The employment rate hit a trough in 2018.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="二倍数表达法"&gt;二、倍数表达法
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用“倍数 + as + 形容词 + as”&lt;/p&gt;
&lt;p&gt;这种表达法适用于比较两个数值，通常用于 “A 是 B 的几倍”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构：&lt;/strong&gt; &lt;strong&gt;A is +&lt;/strong&gt; &lt;strong&gt;倍数&lt;/strong&gt; &lt;strong&gt;+ as +&lt;/strong&gt; &lt;strong&gt;形容词&lt;/strong&gt; &lt;strong&gt;+ as B&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;he population of City A is twice as large as that of City B.&lt;/p&gt;
&lt;p&gt;（A 城市的人口是 B 城市的 两倍。）&lt;/p&gt;
&lt;p&gt;The number of students in 2025 was three times as high as in 2010.&lt;/p&gt;
&lt;p&gt;（2025 年的学生人数是 2010 年的 三倍。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;倍数表达方式:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 倍 twice as&amp;hellip;as&lt;/li&gt;
&lt;li&gt;3 倍 three times as&amp;hellip;as&lt;/li&gt;
&lt;li&gt;4 倍 four times as&amp;hellip;as&lt;/li&gt;
&lt;li&gt;n 倍 n times as&amp;hellip;as&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用“倍数 + 比较级 + than”&lt;/p&gt;
&lt;p&gt;适用于表示增长或减少的程度，强调两者之间的倍数差距。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构：A is + 倍数 + 比较级 + than B&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;The revenue in 2020 was three times higher than that in 2010.&lt;/p&gt;
&lt;p&gt;（2020 年的收入比 2010 年高两倍。）（包含底数在内的倍数～）&lt;/p&gt;
&lt;p&gt;The cost of living in City A is twice more expensive than in City B.&lt;/p&gt;
&lt;p&gt;（A 城市的生活成本是 B 城市的两倍。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用“倍数 + the size/amount/level of”&lt;/p&gt;
&lt;p&gt;适用于描述数量、规模、水平等的倍数变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构：A is + 倍数 + the size/amount/level of B&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;The new shopping mall is twice the size of the old one.&lt;/p&gt;
&lt;p&gt;（新的购物中心是旧购物中心的 两倍大。）&lt;/p&gt;
&lt;p&gt;The profit this year is four times the amount of last year.&lt;/p&gt;
&lt;p&gt;（今年的利润是去年的 四倍。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用“increase/decrease + by + 倍数”&lt;/p&gt;
&lt;p&gt;适用于描述数据的增长或减少，强调增长的倍数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构：increase/decrease + by + 倍数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;The number of cars increased by three times over the past decade.&lt;/p&gt;
&lt;p&gt;（过去十年间，汽车数量增长了 三倍。） to&lt;/p&gt;
&lt;p&gt;The company’s revenue decreased by half in 2023.&lt;/p&gt;
&lt;p&gt;（2023 年，该公司的收入下降了 一半。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用“倍数 + what it was”&lt;/p&gt;
&lt;p&gt;适用于强调某个时间点的数据是过去的几倍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构：A is + 倍数 + what it was + 时间状语&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;The population of the city is three times what it was 50 years ago.&lt;/p&gt;
&lt;p&gt;（这个城市的人口是 50 年前的 三倍。）&lt;/p&gt;
&lt;p&gt;The company’s revenue is twice what it was in 2010.&lt;/p&gt;
&lt;p&gt;（该公司的收入是 2010 年的 两倍。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他倍数相关表达&lt;/p&gt;
&lt;p&gt;A saw a threefold increase in sales.&lt;/p&gt;
&lt;p&gt;（A 公司的销量增加了 三倍。）&lt;/p&gt;
&lt;p&gt;The number of visitors doubled between 2010 and 2020.&lt;/p&gt;
&lt;p&gt;（2010 年到 2020 年间，游客人数 翻了一倍。）&lt;/p&gt;
&lt;p&gt;The crime rate was halved over the decade.&lt;/p&gt;
&lt;p&gt;（犯罪率在十年间减少了一半。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="三表示大约低于高于"&gt;三、表示大约、低于、高于
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表示“大约”&lt;/p&gt;
&lt;p&gt;适用于描述不确定但接近某个数值的数据。&lt;/p&gt;
&lt;p&gt;（1）常用单词&lt;/p&gt;
&lt;p&gt;approximately（大约）&lt;/p&gt;
&lt;p&gt;about（大约）&lt;/p&gt;
&lt;p&gt;around（大约）&lt;/p&gt;
&lt;p&gt;roughly（大致）&lt;/p&gt;
&lt;p&gt;nearly（接近）&lt;/p&gt;
&lt;p&gt;almost（几乎）&lt;/p&gt;
&lt;p&gt;somewhere around（在……左右）&lt;/p&gt;
&lt;p&gt;（2）示例句&lt;/p&gt;
&lt;p&gt;The population of the city was approximately 2 million in 2020.&lt;/p&gt;
&lt;p&gt;（2020 年，该城市人口约 200 万。）&lt;/p&gt;
&lt;p&gt;The unemployment rate was around 5% in 2019.&lt;/p&gt;
&lt;p&gt;（2019 年的失业率 大约 为 5%。）&lt;/p&gt;
&lt;p&gt;The number of tourists reached roughly 10,000.&lt;/p&gt;
&lt;p&gt;（游客数量 大约 达到 10,000 人。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示“低于”&lt;/p&gt;
&lt;p&gt;适用于描述数据比某个数值少。&lt;/p&gt;
&lt;p&gt;（1）常用单词&lt;/p&gt;
&lt;p&gt;below（低于）&lt;/p&gt;
&lt;p&gt;under（低于）&lt;/p&gt;
&lt;p&gt;less than（少于）&lt;/p&gt;
&lt;p&gt;fewer than（少于，适用于可数名词）&lt;/p&gt;
&lt;p&gt;just below（略低于）&lt;/p&gt;
&lt;p&gt;slightly below（略低于）&lt;/p&gt;
&lt;p&gt;marginally below（略低于）&lt;/p&gt;
&lt;p&gt;well below（远低于）&lt;/p&gt;
&lt;p&gt;（2）示例句&lt;/p&gt;
&lt;p&gt;The sales figures were below expectations.&lt;/p&gt;
&lt;p&gt;（销售数据 低于 预期。）&lt;/p&gt;
&lt;p&gt;The average salary was under $50,000 per year.&lt;/p&gt;
&lt;p&gt;（平均工资 低于 每年 50,000 美元。）&lt;/p&gt;
&lt;p&gt;The unemployment rate remained less than 3%.&lt;/p&gt;
&lt;p&gt;（失业率维持在 低于 3%。）&lt;/p&gt;
&lt;p&gt;The student enrollment was slightly below 20,000.&lt;/p&gt;
&lt;p&gt;（学生入学人数 略低于 20,000 人。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示“高于”&lt;/p&gt;
&lt;p&gt;适用于描述数据比某个数值多。&lt;/p&gt;
&lt;p&gt;（1）常用单词&lt;/p&gt;
&lt;p&gt;above（高于）&lt;/p&gt;
&lt;p&gt;over（超过）&lt;/p&gt;
&lt;p&gt;more than（多于）&lt;/p&gt;
&lt;p&gt;greater than（大于）&lt;/p&gt;
&lt;p&gt;exceed（超过）&lt;/p&gt;
&lt;p&gt;surpass（超过）&lt;/p&gt;
&lt;p&gt;just above（略高于）&lt;/p&gt;
&lt;p&gt;slightly above（略高于）&lt;/p&gt;
&lt;p&gt;marginally above（略高于）&lt;/p&gt;
&lt;p&gt;well above（远高于）&lt;/p&gt;
&lt;p&gt;（2）示例句&lt;/p&gt;
&lt;p&gt;The temperature was above 30°C in summer.&lt;/p&gt;
&lt;p&gt;（夏天的气温 高于 30°C。）&lt;/p&gt;
&lt;p&gt;The number of participants was over 1,000.&lt;/p&gt;
&lt;p&gt;（参赛人数 超过 1,000 人。）&lt;/p&gt;
&lt;p&gt;The company’s revenue exceeded $5 million.&lt;/p&gt;
&lt;p&gt;（公司的收入 超过 500 万美元。）&lt;/p&gt;
&lt;p&gt;The literacy rate was slightly above 95%.&lt;/p&gt;
&lt;p&gt;（识字率 略高于 95%。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结合表达&lt;/p&gt;
&lt;p&gt;可以结合大约、低于、高于来更准确描述数据：&lt;/p&gt;
&lt;p&gt;just over / just above（略高于）&lt;/p&gt;
&lt;p&gt;just under / just below（略低于）&lt;/p&gt;
&lt;p&gt;somewhere between… and…（介于……和……之间）&lt;/p&gt;
&lt;p&gt;示例句：&lt;/p&gt;
&lt;p&gt;The population was just over 10 million in 2021.&lt;/p&gt;
&lt;p&gt;（2021 年人口 略高于 1,000 万。）&lt;/p&gt;
&lt;p&gt;The unemployment rate was just under 5%.&lt;/p&gt;
&lt;p&gt;（失业率 略低于 5%。）&lt;/p&gt;
&lt;p&gt;The price was somewhere between $10and10 and $15.&lt;/p&gt;
&lt;p&gt;（价格在 10 到 15 美元之间。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="四进一步阐释的衔接词"&gt;四、进一步阐释的衔接词
&lt;/h2&gt;&lt;h3 id="this-means这意味着"&gt;This means（这意味着）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;用于解释某个数据的 含义、影响或推论，相当于 &amp;ldquo;This implies&amp;rdquo; 或 &amp;ldquo;This indicates&amp;rdquo;。
常用于推导结论、解释数据的意义或趋势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;句型：&lt;/p&gt;
&lt;p&gt;A + increased/decreased, this means + 结果&lt;/p&gt;
&lt;p&gt;This means that + 句子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;The number of online shoppers increased by 20% in 2023. This means that e-commerce is becoming more popular.&lt;/p&gt;
&lt;p&gt;（2023 年在线购物者数量增长了 20%，这意味着 电子商务正变得越来越受欢迎。）&lt;/p&gt;
&lt;p&gt;The unemployment rate dropped to 3%. This means fewer people are out of work.&lt;/p&gt;
&lt;p&gt;（失业率下降到 3%，这意味着 失业人数减少了。）&lt;/p&gt;
&lt;p&gt;The population aged 65 and above accounted for 25% of the total. This means that the country is experiencing an aging society.&lt;/p&gt;
&lt;p&gt;（65 岁及以上人口占总人口的 25%，这意味着 该国正在经历老龄化。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="this-represents这代表占-this--amounts-to-an-increase-of-10"&gt;This represents（这代表/占……） This &amp;hellip;.. amounts to an increase of 10%
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;用于说明某个数据或比例在整体中的占比或意义，相当于 &amp;ldquo;This accounts for&amp;rdquo; 或 &amp;ldquo;This constitutes&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;适用于 百分比、比例、数据变化 的描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;句型：&lt;/p&gt;
&lt;p&gt;A represents B（A 代表 B）&lt;/p&gt;
&lt;p&gt;A represents X% of B（A 占 B 的 X%）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;Renewable energy represents 35% of the total electricity production.&lt;/p&gt;
&lt;p&gt;（可再生能源 占 总发电量的 35%。）&lt;/p&gt;
&lt;p&gt;The number of electric cars sold in 2024 represents a significant increase compared to the previous year.&lt;/p&gt;
&lt;p&gt;（2024 年销售的电动车数量 代表 相较前一年的显著增长。）&lt;/p&gt;
&lt;p&gt;The government’s budget for education represents 15% of total expenditure.&lt;/p&gt;
&lt;p&gt;（政府的教育预算 占 总支出的 15%。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="this-amounts-to这相当于总计为"&gt;This amounts to（这相当于/总计为）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;p&gt;用于描述 总数、金额、时间、成本 等的计算结果，意思类似于 &amp;ldquo;This equals&amp;rdquo; 或 &amp;ldquo;This totals&amp;rdquo;。常用于累计数据的表达，表示一个数据加起来等于多少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;句型：&lt;/p&gt;
&lt;p&gt;A amounts to B（A 相当于 B）&lt;/p&gt;
&lt;p&gt;This amounts to + 数字/比例/结论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;The total revenue amounts to $5 million this year.&lt;/p&gt;
&lt;p&gt;（今年的总收入 相当于 500 万美元。）&lt;/p&gt;
&lt;p&gt;The water consumption per household amounts to 500 liters per week.&lt;/p&gt;
&lt;p&gt;（每户的用水量 总计 每周 500 升。）&lt;/p&gt;
&lt;p&gt;The increase in tuition fees amounts to an additional cost of $2,000 per student per year.&lt;/p&gt;
&lt;p&gt;（学费的上涨 相当于 每名学生每年额外支付 2000 美元。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="五其他好用的表达"&gt;五、其他好用的表达
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表示“变化趋势”&lt;/p&gt;
&lt;p&gt;适用于描述数据变化的趋势而非具体数值。&lt;/p&gt;
&lt;p&gt;（1）show a tendency to…（呈现……的趋势）&lt;/p&gt;
&lt;p&gt;e.g. The birth rate showed a tendency to decline after 2010.&lt;/p&gt;
&lt;p&gt;（2）follow an upward/downward trajectory（呈上升/下降轨迹）&lt;/p&gt;
&lt;p&gt;e.g. The stock prices followed an upward trajectory throughout the year.&lt;/p&gt;
&lt;p&gt;（3）demonstrate a steady pattern（表现出稳定的模式）&lt;/p&gt;
&lt;p&gt;e.g. The sales figures demonstrated a steady pattern over the decade.&lt;/p&gt;
&lt;p&gt;（4）experience a period of stability（经历一段稳定期）&lt;/p&gt;
&lt;p&gt;e.g. The inflation rate experienced a period of stability from 2015 to 2018.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示“起伏波动”&lt;/p&gt;
&lt;p&gt;适用于描述数据在一段时间内波动变化。&lt;/p&gt;
&lt;p&gt;（1）fluctuate wildly/slightly（大幅/小幅波动）&lt;/p&gt;
&lt;p&gt;e.g. The oil prices fluctuated wildly due to market uncertainty.&lt;/p&gt;
&lt;p&gt;（2）go through ups and downs（经历起伏变化）&lt;/p&gt;
&lt;p&gt;e.g. The housing market went through ups and downs over the decade.&lt;/p&gt;
&lt;p&gt;（3）remain volatile（保持波动）&lt;/p&gt;
&lt;p&gt;e.g. The exchange rate remained volatile throughout the year.&lt;/p&gt;
&lt;p&gt;（4）witness erratic changes（见证不规律的变化）&lt;/p&gt;
&lt;p&gt;e.g. The stock market witnessed erratic changes in the first quarter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示“达到某个点”&lt;/p&gt;
&lt;p&gt;适用于描述数据到达某个高点或低点。&lt;/p&gt;
&lt;p&gt;（1）reach a new peak（达到新高）&lt;/p&gt;
&lt;p&gt;e.g. The demand for electric vehicles reached a new peak in 2023.&lt;/p&gt;
&lt;p&gt;（2）hit an all-time high/low（达到历史最高/最低点）&lt;/p&gt;
&lt;p&gt;e.g. The unemployment rate hit an all-time low in 2021.&lt;/p&gt;
&lt;p&gt;（3）bottom out（触底反弹）&lt;/p&gt;
&lt;p&gt;e.g. The stock prices bottomed out in March before recovering.&lt;/p&gt;
&lt;p&gt;（4）plateau at…（稳定在……）&lt;/p&gt;
&lt;p&gt;e.g. The number of tourists plateaued at around 1 million.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示“速度快慢”&lt;/p&gt;
&lt;p&gt;适用于描述变化的快慢程度。&lt;/p&gt;
&lt;p&gt;（1）change at a rapid pace（以快速速度变化）&lt;/p&gt;
&lt;p&gt;e.g. The number of internet users changed at a rapid pace.&lt;/p&gt;
&lt;p&gt;（2）see a sluggish increase（缓慢增长）&lt;/p&gt;
&lt;p&gt;e.g. The aging population saw a sluggish increase over the decade.&lt;/p&gt;
&lt;p&gt;（3）progress gradually（逐步变化）&lt;/p&gt;
&lt;p&gt;e.g. The cost of living progressed gradually over the years.&lt;/p&gt;
&lt;p&gt;（4）surge abruptly（突然激增）&lt;/p&gt;
&lt;p&gt;e.g. The sales of masks surged abruptly during the pandemic.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示“比较两种趋势”&lt;/p&gt;
&lt;p&gt;适用于描述两个数据对比的趋势。&lt;/p&gt;
&lt;p&gt;（1）move in opposite directions（朝相反方向变化）&lt;/p&gt;
&lt;p&gt;e.g. The price of gold and the stock market moved in opposite directions.&lt;/p&gt;
&lt;p&gt;（2）follow a similar/opposite pattern（遵循相似/相反模式）&lt;/p&gt;
&lt;p&gt;e.g. The trends in urban and rural areas followed a similar pattern.&lt;/p&gt;
&lt;p&gt;（3）diverge significantly（显著分化）&lt;/p&gt;
&lt;p&gt;e.g. The GDP growth rates of the two countries diverged significantly after 2015.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="六介绍数据图表"&gt;六、介绍数据/图表
&lt;/h2&gt;&lt;p&gt;在小作文的开头，通常需要介绍图表类型和主要内容。&lt;/p&gt;
&lt;h3 id="常用句型"&gt;常用句型
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;The graph/chart/table/diagram illustrates/shows/compares…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e.g. The bar chart illustrates the number of tourists visiting three different countries from 2010 to 2020.&lt;/p&gt;
&lt;p&gt;（柱状图展示了 2010 年到 2020 年间访问三个不同国家的游客数量。）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The data is measured in…（数据单位是…）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e.g. The figures are measured in percentages.&lt;/p&gt;
&lt;p&gt;（数据以百分比为单位。）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The table provides information on…（表格提供了关于…的信息）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e.g. The table provides information on the population growth in five major cities.&lt;/p&gt;
&lt;p&gt;（表格提供了五个主要城市的人口增长情况。）&lt;/p&gt;
&lt;h3 id="过渡与对比transitions--comparisons"&gt;过渡与对比（Transitions &amp;amp; Comparisons）
&lt;/h3&gt;&lt;p&gt;用于连接数据变化、不同类别或时间段之间的比较。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表示对比&lt;/p&gt;
&lt;p&gt;In contrast to…（与……相比）&lt;/p&gt;
&lt;p&gt;e.g. In contrast to 2010, the employment rate in 2020 was significantly higher.&lt;/p&gt;
&lt;p&gt;（与 2010 年相比，2020 年的就业率明显更高。）&lt;/p&gt;
&lt;p&gt;Compared with…（与……相比）&lt;/p&gt;
&lt;p&gt;e.g. Compared with 2005, the number of students increased by 50%.&lt;/p&gt;
&lt;p&gt;（与 2005 年相比，学生人数增长了 50%。）&lt;/p&gt;
&lt;p&gt;While A increased, B decreased.（A 增加，而 B 下降）&lt;/p&gt;
&lt;p&gt;e.g. While the price of oil increased, the cost of natural gas dropped sharply.&lt;/p&gt;
&lt;p&gt;（石油价格上涨，而天然气价格大幅下降。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示相似&lt;/p&gt;
&lt;p&gt;A and B follow a similar pattern.（A 和 B 遵循相似的模式）&lt;/p&gt;
&lt;p&gt;e.g. The trends in Europe and Asia follow a similar pattern.&lt;/p&gt;
&lt;p&gt;（欧洲和亚洲的趋势相似。）&lt;/p&gt;
&lt;p&gt;Both A and B show an upward trend.（A 和 B 都呈上升趋势）&lt;/p&gt;
&lt;p&gt;e.g. Both the US and Canada show an upward trend in energy consumption.&lt;/p&gt;
&lt;p&gt;（美国和加拿大的能源消耗都呈上升趋势。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="强调数据变化"&gt;强调数据变化
&lt;/h3&gt;&lt;p&gt;用于突出某个数据的变化幅度、重要性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表示“显著变化”&lt;/p&gt;
&lt;p&gt;There was a dramatic increase in…（……有显著增长）&lt;/p&gt;
&lt;p&gt;e.g. There was a dramatic increase in the number of electric vehicles sold.&lt;/p&gt;
&lt;p&gt;（电动车的销量大幅增长。）&lt;/p&gt;
&lt;p&gt;The figure rose significantly to…（数据显著上升到……）&lt;/p&gt;
&lt;p&gt;e.g. The number of tourists rose significantly to 2 million in 2022.&lt;/p&gt;
&lt;p&gt;（2022 年游客人数显著增长到 200 万。）&lt;/p&gt;
&lt;p&gt;A sharp decline was observed in…（在……中观察到急剧下降）&lt;/p&gt;
&lt;p&gt;e.g. A sharp decline was observed in the birth rate between 2010 and 2020.&lt;/p&gt;
&lt;p&gt;（2010 年到 2020 年间，出生率急剧下降。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表示“小幅变化”&lt;/p&gt;
&lt;p&gt;There was a slight increase in…（……略有增长）&lt;/p&gt;
&lt;p&gt;e.g. There was a slight increase in the number of online courses.&lt;/p&gt;
&lt;p&gt;（在线课程的数量略有增长。）&lt;/p&gt;
&lt;p&gt;The number remained relatively stable at…（数量保持相对稳定在……）&lt;/p&gt;
&lt;p&gt;e.g. The unemployment rate remained relatively stable at around 5%.&lt;/p&gt;
&lt;p&gt;（失业率保持相对稳定在 5% 左右。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="预测趋势或推断"&gt;预测趋势或推断
&lt;/h3&gt;&lt;p&gt;在某些题型（如动态折线图）中，可能需要推测未来趋势。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表达未来趋势&lt;/p&gt;
&lt;p&gt;It is predicted that…（据预测……）forecast&lt;/p&gt;
&lt;p&gt;e.g. It is predicted that the number of electric vehicles will continue to rise.&lt;/p&gt;
&lt;p&gt;（据预测，电动车数量将持续增长。）&lt;/p&gt;
&lt;p&gt;This trend is expected to continue.（预计这一趋势将继续）&lt;/p&gt;
&lt;p&gt;e.g. The demand for solar energy is expected to continue growing.&lt;/p&gt;
&lt;p&gt;（太阳能的需求预计会继续增长。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表达可能性&lt;/p&gt;
&lt;p&gt;It is likely that…（很可能……）&lt;/p&gt;
&lt;p&gt;e.g. It is likely that internet usage will increase further.&lt;/p&gt;
&lt;p&gt;（互联网使用率很可能会进一步上升。）&lt;/p&gt;
&lt;p&gt;There is a high possibility that…（有很大可能……）&lt;/p&gt;
&lt;p&gt;e.g. There is a high possibility that global temperatures will keep rising.&lt;/p&gt;
&lt;p&gt;（全球气温很可能继续上升。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>IELTS备考-1</title><link>https://cxzhou.com/p/ielts-1/</link><pubDate>Sun, 06 Jul 2025 15:20:00 +0800</pubDate><guid>https://cxzhou.com/p/ielts-1/</guid><description>&lt;img src="https://cxzhou.com/p/ielts-1/cover.png" alt="Featured image of post IELTS备考-1" /&gt;&lt;h2 id="写作评分标准"&gt;写作评分标准
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Task Response: 完整回答问题，涵盖所有要点&lt;/li&gt;
&lt;li&gt;Coherence and Cohesion: 文章结构清晰，段落之间逻辑连贯，使用合适的连接词&lt;/li&gt;
&lt;li&gt;Lexical Resource: 使用了丰富的词汇，准确地使用词汇表达观点&lt;/li&gt;
&lt;li&gt;Grammatical Range and Accuracy: 使用了多样化的语法结构，语法错误是否影响理解&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;时间分配：&lt;/strong&gt; Task 1约20分钟，完成180词，Task 2约40分钟完成280词&lt;/p&gt;
&lt;h2 id="task-1"&gt;Task 1
&lt;/h2&gt;&lt;p&gt;根据给出的&lt;strong&gt;图表、表格、地图或流程图&lt;/strong&gt;等信息，写一篇150字左右的报告，对信息进行描述和总结。重点在于准确地理解和呈现数据、趋势或过程。&lt;/p&gt;
&lt;h3 id="四段式结构"&gt;四段式结构
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;para.1 改写background information
&lt;img src="image1.png" alt="改写"&gt;
&lt;ul&gt;
&lt;li&gt;常用句式：
&lt;ul&gt;
&lt;li&gt;The first/top &amp;hellip; shows &amp;hellip; , the second/bottom &amp;hellip; shows (the number/ammount/quantity of) &amp;hellip;&lt;/li&gt;
&lt;li&gt;Together with &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图表：line graph(折线图), bar chart(柱状图), pie chart(饼状图), table(表), map(地图), diagram/flow chart(流程图)&lt;/li&gt;
&lt;li&gt;类别：category/kind/sort&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;para.2 总结最重要的两个要点信息
通常两张图表，每张总结一个；一张图表则横纵对比、找极值等。
&lt;ul&gt;
&lt;li&gt;常用句式：
&lt;ul&gt;
&lt;li&gt;Overall, there are 2 key points (to note).&lt;/li&gt;
&lt;li&gt;First,..And secondly,.. &lt;em&gt;OR&lt;/em&gt; Overall, the main point to note is that…. &lt;em&gt;OR&lt;/em&gt; Overall, the main points to note are that XXX and YYY.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;para.3 &amp;amp; 4 详细讲两个要点
&lt;ul&gt;
&lt;li&gt;常用句式：
&lt;ul&gt;
&lt;li&gt;Looking at the first graph in more detail, it can be seen that(we can see that) &amp;hellip;&lt;/li&gt;
&lt;li&gt;Turning to the &amp;hellip;&lt;/li&gt;
&lt;li&gt;It is also noteworthy that &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>OPT学习笔记-0</title><link>https://cxzhou.com/p/opt-notes-0/</link><pubDate>Mon, 23 Jun 2025 20:00:00 +0800</pubDate><guid>https://cxzhou.com/p/opt-notes-0/</guid><description>&lt;img src="https://cxzhou.com/p/opt-notes-0/cover.jpg" alt="Featured image of post OPT学习笔记-0" /&gt;&lt;h2 id="basic-definition"&gt;Basic Definition
&lt;/h2&gt;&lt;p&gt;OPT is short for Optimization, and an optimization problem is defined as follow:&lt;/p&gt;
&lt;div class="math-block math-block--definition" id="def-opt"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 0: optimization problem&lt;/strong&gt;&lt;a href="#def-opt" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
$$
\min \space f(x) \\
s.t. \space x\in X
$$&lt;p&gt;
where $f: \mathbb{R}^n \to \mathbb{R}$ is called the &lt;em&gt;objective function (决策函数)&lt;/em&gt;, $x$ is the &lt;em&gt;decision variable (决策变量)&lt;/em&gt;， and $X$ is the &lt;em&gt;feasible region (可行域)&lt;/em&gt; . Moreover, $min$ for &lt;em&gt;minimize&lt;/em&gt; and $s.t.$ for &lt;em&gt;subject to&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="def-optimal"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 1: 全局最优解及最优值 (global) optimal solution &amp;amp; optimal value&lt;/strong&gt;&lt;a href="#def-optimal" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;$x^\*$ is an optimal solution of &lt;a class="link" href="#def-opt" &gt;1&lt;/a&gt;
&lt;em&gt;iff.&lt;/em&gt; $ \space x^\* \in X, f(x^\*)\leq f(x), \forall x\in X$
where $f(x^\*)$ is the optimal value of &lt;a class="link" href="#def-opt" &gt;1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some special cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;infeasible(不可行)：&lt;/em&gt; $X = \emptyset$;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;unbounded(无界)：&lt;/em&gt;$(x^n)_{n=1}^{\infin}\in X$, $f(x^n)\to \infty$;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;not achieved(无法取得):&lt;/em&gt; not exist $ x^* \in X $, so that $ f(x^*)=inf\{f(x)|x\in X\} $&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="def-min"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 2: 局部极小值点&lt;/strong&gt;&lt;a href="#def-min" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;$\bar{x}$ is a &lt;em&gt;local minimum(局部极小值点)&lt;/em&gt; of function $f$, if there exists $\delta&gt;0$ such that
&lt;/p&gt;
$$f(\bar{x})\leq f(x), \forall x\in X, ||x-\bar{x}||_2&lt;\delta$$&lt;p&gt;
$\bar{x}$ is a &lt;em&gt;strict local minimum&lt;/em&gt; of function $f$, if there exists $\delta&gt;0$ such that
&lt;/p&gt;
$$f(\bar{x})&lt; f(x), \forall x\in X, ||x-\bar{x}||_2&lt;\delta\space and\space x\neq \bar{x}$$
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="mathematical-foundations"&gt;Mathematical Foundations
&lt;/h2&gt;&lt;h3 id="linear-algebra"&gt;Linear Algebra
&lt;/h3&gt;&lt;h4 id="the-space"&gt;The space $\mathbb{R}^n$
&lt;/h4&gt;&lt;p&gt;A &lt;strong&gt;vector&lt;/strong&gt; (or point) $x$ in $\mathbb{R}^n$ is an ordered collection of $n$ real numbers, which can be given as $x=(x_1,x_2,x_3,\cdots,x_n)$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;scalar multiplication(数乘)&lt;/strong&gt; $a\in \mathbb{R}, x \in \mathbb{R}^n, ax=(ax_1,ax_2,\cdots,ax_n)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;addition(向量加法)&lt;/strong&gt; $x\in\mathbb{R}^n, y\in\mathbb{R}^n, x+y=(x_1+y_1,x_2+y_2,\cdots,x_n+y_n)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;linear subspace(线性子空间)&lt;/strong&gt; A nonempty subset $S$ of $\mathbb{R}^n$ is a &lt;em&gt;linear subspace&lt;/em&gt; &lt;em&gt;iff.&lt;/em&gt;
&lt;/p&gt;
$$
x,y\in S, x+y\in S;x\in S,a\in \mathbb{R},ax\in S
$$&lt;p&gt;
(对加法和数乘封闭)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;linear combinations(线性组合) &amp;amp; span(线性生成空间)&lt;/strong&gt;
&lt;/p&gt;
$$
\mathcal{V}=\{v_1,v_2,\cdots,v_m\}\in \mathbb{R}^n, a_1,a_2,\cdots,a_m\in\mathbb{R}
$$&lt;p&gt;$\sum_{i=1}^ma_iv_i$ is a &lt;em&gt;linear combination&lt;/em&gt;;&lt;/p&gt;
$$
span(\mathcal{V}):=\{ a_1v_1+a_2v_2+\cdots+a_mv_m \mid a_1,a_2,\cdots,a_m\in\mathbb{R} \}
$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;linear independent(线性无关) &amp;amp; linear dependent(线性相关)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;linear independent:&lt;/em&gt; $v=a_1v_1+a_2v_2+\cdots+a_mv_m=\mathbf{0}$ &lt;em&gt;iff.&lt;/em&gt; $a_1=a_2=\cdots=a_m=0$&lt;/p&gt;
&lt;p&gt;&lt;em&gt;linear dependent:&lt;/em&gt; exists a non-zero ${a_k}$, such that $v=\mathbf{0}$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Basis(基)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\mathcal{V}$ is a &lt;em&gt;basis&lt;/em&gt; of linear subspace $S$ of $\mathbb{R}^n$, if $span(\mathcal{V})=S$ and $\mathcal{V}$ is linear independent&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some useful facts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The span of $\mathcal{V}$ is a linear subspace of $\mathbb{R}^n$;&lt;/li&gt;
&lt;li&gt;$\mathcal{V}$ is linear independent if and only if every $v\in span(\mathcal{V})$ can be uniquely represented as a linear combination of $\mathcal{V}$;&lt;/li&gt;
&lt;li&gt;$\mathcal{V}$ is linear independent. If $v\notin span(\mathcal{V})$ the $\mathcal{V}\cup v$ is linear independent;&lt;/li&gt;
&lt;li&gt;If $\mathcal{V}$ is linear dependent, there exists a nonzero vector $v\in\mathcal{V}$ such that $v\in span(\mathcal{V\backslash v}), span(\mathcal{V})=span(\mathcal{V\backslash v})$.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math-block math-block--theorem" id="theo-basis"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Theorem 1 (基扩充/缩减定理)&lt;/strong&gt;&lt;a href="#theo-basis" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
Every linear independent subset of $\mathcal{V}$ can be extended to a basis of $span(\mathcal{V})$. The set of $\mathcal{V}$ can be reduced to a basis of $span(\mathcal{V})$.
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;(重复加入/减去线性无关向量直到构成基)&lt;/strong&gt;&lt;/p&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Proposition 1&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
Let $\mathcal{W}$ be a vector space spanned by a finite set $\mathcal{V}$, i.e., $\mathcal{W}=span(\mathcal{V})$. Any linearly independent subset of $\mathcal{W}$ can be extended to form a basis for $\mathcal{W}$ .
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;Let $L=\{v_1,v_2,…,v_k\}$ be a linearly independent set of vectors in W. We want to find a set of vectors ${u_1,u_2,…,u_m}\subseteq \mathcal{V}$ such that the combined set $B=L∪\{u_1,…,u_m\}$ is a basis for $\mathcal{W}$ .&lt;/p&gt;
&lt;p&gt;We proceed with the following algorithm:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Check if&lt;/strong&gt; $L$ &lt;strong&gt;spans&lt;/strong&gt; $\mathcal{W}$ .&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If $span(L)=\mathcal{W}$, then $L$ is a linearly independent spanning set, which means $L$ is already a basis for $\mathcal{W}$. The proof is complete.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;If&lt;/strong&gt; $L$ &lt;strong&gt;does not span&lt;/strong&gt; $\mathcal{W}$ &lt;strong&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If $span(L)\neq\mathcal{W} $, then there must exist at least one vector in $\mathcal{W}$ that is not in the span of $L$. Since $\mathcal{W}=span(\mathcal{V})$, there must be a vector $u_1∈\mathcal{V}$ such that $u_1\notin span(\mathcal{V})$.&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s form a new set $L_1=L∪\{u_1\}=\{v_1,…,v_k,u_1\}$. We claim this new set is also linearly independent.&lt;/li&gt;
&lt;li&gt;To prove this, consider the equation:
$c_1v_1+c_2v_2+⋯+c_kv_k+d_1u_1=0$&lt;/li&gt;
&lt;li&gt;Case 1: If $d1\neq 0$, we could rearrange the equation to express u1 as a linear combination of the vectors in $L$:
$u_1=−d_{11}(c_1v_1+⋯+c_kv_k)$
This would imply that $u1\in span(L)$, which contradicts our choice of u1.&lt;/li&gt;
&lt;li&gt;Case 2: Therefore, we must have $d_1=0$. The equation simplifies to:
$c_1v_1+c_2v_2+⋯+c_kv_k=0$
Since $L$ is a linearly independent set, the only solution to this equation is $c_1=c_2=⋯+c_k=0$.&lt;/li&gt;
&lt;li&gt;Thus, the only solution is that all coefficients ($c_i$ and $d_1$) are zero. This proves that the set $L_1$ is linearly independent.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Repeat the process.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We now repeat the procedure with $L_1$. If $span(L_1)=\mathcal{W}$, we have found our basis. If not, we find another vector $u_2\in V$ such that $u_2\notin span(L_1)$ and form the larger, linearly independent set $L_2=L_1∪\{u_2\}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Since W is spanned by a finite set V, it is a finite-dimensional space. Let $dim(\mathcal{W})=n$. Any linearly independent set in $\mathcal{W}$ can contain at most n vectors. Our process starts with a set of k vectors and adds one vector at a time, maintaining linear independence at each step. Therefore, the process is guaranteed to terminate in at most n−k steps, at which point we have a set $B$ that is linearly independent and spans $\mathcal{W}$. By definition, $B$ is a basis for $\mathcal{W}$ that contains the original set $L$.&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Proposition 2&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
Any finite set $\mathcal{V}$ that spans a vector space W can be reduced to a basis for $\mathcal{W}$ by removing some of its vectors.
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;p&gt;Let $\mathcal{V}=\{v_1,v_2,\cdots,v_m\}$ be a set that spans $\mathcal{W}$, i.e., $\mathcal{W}=span(\mathcal{V})$. We want to find a subset $B\subseteq \mathcal{V}$ that is a basis for $\mathcal{W}$.&lt;/p&gt;
&lt;p&gt;We can construct the basis $B$ using the following &amp;ldquo;sifting&amp;rdquo; algorithm:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Initialize an empty set, $B=\empty$.&lt;/li&gt;
&lt;li&gt;Iterate through each vector $v_i$ in $\mathcal{V}$ for $i=1,\cdots,m$.&lt;/li&gt;
&lt;li&gt;For each $v_i$, check if it is a linear combination of the vectors already in $B$. That is, check if $v_i\in span(B)$.
&lt;ul&gt;
&lt;li&gt;If &lt;strong&gt;NO&lt;/strong&gt;, then $v_i$ is linearly independent of the vectors in $B$. Add $v_i$ to $B$.&lt;/li&gt;
&lt;li&gt;If &lt;strong&gt;YES&lt;/strong&gt;, then vi is a redundant vector (it depends linearly on other vectors). Discard $v_i$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The final set $B$ produced by this algorithm is a basis for $\mathcal{W}$. We must prove two properties: that $B$ is linearly independent and that it spans $\mathcal{W}$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Linear Independence:&lt;/strong&gt; By construction, a vector is only added to $B$ if it is not in the span of the vectors already in $B$. This condition directly ensures that the resulting set $B$ is linearly independent. If $B=\{b_1,\cdots,b_k\}$ were linearly dependent, then by the properties of linear dependence, some vector $b_j$ would be a linear combination of the preceding vectors, $b_j\in span(\{b_1,…,b_{j−1}\})$. But this contradicts the very rule we used to add $b_j$ to the set. Therefore, $B$ must be linearly independent.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spanning Property:&lt;/strong&gt; We need to show that $span(B)=span(\mathcal{V})$.
&lt;ul&gt;
&lt;li&gt;Since $B\subseteq\mathcal{V}$, it is clear that $span(B)\subseteq span(V)$.&lt;/li&gt;
&lt;li&gt;To show $span(V)\subseteq span(B)$, we must show that every vector $v_i\in \mathcal{V}$ is in $span(B)$.
&lt;ul&gt;
&lt;li&gt;If a vector $v_i$ was added to $B$, then $v_i∈B$, so it is trivially in $span(B)$.&lt;/li&gt;
&lt;li&gt;If a vector $v_i$ was discarded, it was because at the moment of its consideration, it was already a linear combination of the vectors in the current version of $B$. Since the final set $B$ contains all these vectors, it follows that $v_i\in span(B)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Since every vector in the original spanning set $\mathcal{V}$ can be expressed as a linear combination of vectors in $B$, the span of $\mathcal{V}$ cannot be larger than the span of $B$. Thus, $span(\mathcal{V})\subseteq span(B)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Combining the two inclusions, we have $span(B)=span(\mathcal{V})=\mathcal{W}$.&lt;/p&gt;
&lt;p&gt;Since $B$ is a linearly independent set that spans $\mathcal{W}$, it is a basis for $\mathcal{W}$.&lt;/p&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id="euclidean-inner-product-euclidean-norm-orthogonal"&gt;Euclidean inner product, Euclidean norm, orthogonal
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Euclidean inner product&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math-block math-block--definition" id="def-product"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 3: Euclidean inner product(欧氏内积)&lt;/strong&gt;&lt;a href="#def-product" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;Given two vectors $x, y \in \mathbb{R}^n$, their &lt;strong&gt;Euclidean inner product&lt;/strong&gt; is defined as&lt;br&gt;
&lt;/p&gt;
$$
\langle x, y \rangle=\sum_{i=1}^n x_i y_i
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Properties of the inner product&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bi-linearity(双线性性):&lt;/strong&gt; when $\bar{x}$ is a fixed vector in $\mathbb{R}^n$, the function $&lt;\bar{x}, y&gt;$ is linear in variable $y$; when $\bar{y}$ is a fixed vector in $\mathbb{R}^n$, the function $&lt;x, \bar{y}&gt;$ is linear in variable $x$;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;symmetry(对称性):&lt;/strong&gt; $&lt;x, y&gt;=&lt;y, x&gt;, \forall x, y \in \mathbb{R}^n$;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;positive definiteness(正定性):&lt;/strong&gt; $\forall x \in \mathbb{R}^n, &lt;x, x&gt;\geq 0$, and is zero &lt;em&gt;iff.&lt;/em&gt; $x=\mathbf{0}$&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" &gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Definition 4: Linear function&lt;/strong&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;A function $f: \mathbb{R}^n \to \mathbb{R}$ is linear if for every $ x,y \in \mathbb{R}^n $ and $ \alpha, \beta \in \mathbb{R} $,
&lt;/p&gt;
$$
f(\alpha x+ \beta y)=\alpha f(x)+ \beta f(y)
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="theo-func"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Theorem 2 (线性函数可由向量内积唯一表示)&lt;/strong&gt;&lt;a href="#theo-func" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;Let $&lt;\cdot , \cdot&gt;$ be the &lt;em&gt;Euclidean inner product&lt;/em&gt; on $\mathbb{R}^n \to \mathbb{R}$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For every vector $a \in \mathbb{R}^n$, $&lt;a,x&gt;$ is a linear function from $ \mathbb{R}^n \to \mathbb{R} $,&lt;/li&gt;
&lt;li&gt;Let $f(x)$ be a linear function from $ \mathbb{R}^n \to \mathbb{R} $. Then, there exists a unique vector $a\in \mathbb{R}^n$ so that $f(x)=&lt;a, x&gt;$ for every $x\in \mathbb{R}^n$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--proof" &gt;
&lt;div class="math-block-content"&gt;
&lt;em&gt;&lt;strong&gt;证明.&lt;/strong&gt;&lt;/em&gt;&amp;nbsp;
&lt;ol&gt;
&lt;li&gt;Let $f(x)=&lt;a, x&gt;$, for every $x, y\in \mathbb{R}^n$ and $\alpha, \beta \in \mathbb{R}$
$$
\begin{align*}
f(\alpha x+ \beta y) &amp;= \langle a, \alpha x+ \beta y \rangle \\
&amp;= \alpha \langle a, x \rangle + \beta \langle a, y \rangle \\
&amp;= \alpha f(x) + \beta f(y)
\end{align*}
$$
$f(x)$ is a linear function;&lt;/li&gt;
&lt;li&gt;Let $f(x)$ be a linear function,
$$
\begin{align*}
f(x) &amp;=f(\sum x_ie_i) \\
&amp;=\sum x_if(e_i) \\
&amp;=\langle a, x \rangle
\end{align*}
$$
in which $a=(f(e_1),\cdots,f(e_n))$.&lt;/li&gt;
&lt;/ol&gt;
&lt;span class="qed-symbol"&gt;□&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Extending Theorem 2 from scalar-valued linear functions $f: \mathbb{R}^n \to \mathbb{R}$ to vector-valued linear functions $f: \mathbb{R}^n \to \mathbb{R}^m$, we derive the following corollary:&lt;/p&gt;
&lt;div class="math-block math-block--theorem" id="coro-3"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Corollary 3&lt;/strong&gt;&lt;a href="#coro-3" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;ul&gt;
&lt;li&gt;Let $A$ be a $m \times n$ matrix whose row vectors are $a_1^T,\cdots,a_m^T$. Then, $Ax$ is a linear function from $\mathbb{R}^n \to \mathbb{R}^m$;&lt;/li&gt;
&lt;li&gt;Let $f(x)$ be a linear function from $\mathbb{R}^n \to \mathbb{R}^m$. Then there exists a unique $m \times n$ matrix $A$ such that $f(x)=Ax$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ol start="2"&gt;
&lt;li&gt;&lt;strong&gt;Euclidean norm&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math-block math-block--definition" id="def-norm"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Euclidean norm(欧几里得范数)&lt;/strong&gt;&lt;a href="#def-norm" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;The &lt;strong&gt;Euclidean norm&lt;/strong&gt; of $x\in \mathbb{R}^n$ is defined as
&lt;/p&gt;
$$
||x||_2=\sqrt{\langle x,x \rangle}=\sqrt{\sum_{i=1}^n x_i^2}.
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;An important inequality: &lt;strong&gt;Cauchy-Schwarz inequality(柯西施瓦茨不等式)&lt;/strong&gt;
&lt;/p&gt;
$$
|\langle x,y \rangle|\leq||x||_2\cdot ||y||_2.
$$&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;orthogonal(正交)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$x$ and $y$ are orthogonal &lt;em&gt;iff.&lt;/em&gt; $&lt;x,y&gt;=0$.&lt;/p&gt;
&lt;h4 id="four-fundamental-subspaces"&gt;Four fundamental subspaces
&lt;/h4&gt;
&lt;div class="math-block math-block--definition" id="def-col"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Column Space&lt;/strong&gt;&lt;a href="#def-col" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;The column space of matrix $ A $, denoted $ Col(A) $, is the subspace spanned by the linear combinations of its column vectors.
&lt;/p&gt;
$$
Col(A) = \{ A\mathbf{x} \mid \mathbf{x} \in \mathbb{R}^n \}
$$&lt;p&gt;
where $ A $ is an $ m \times n $ matrix and $ \mathbf{x} $ is an $ n $-dimensional vector.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="def-row"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Row Space&lt;/strong&gt;&lt;a href="#def-row" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;The row space of matrix $ A $, denoted $ \text{Row}(A) $, is the subspace spanned by the linear combinations of its row vectors.
&lt;/p&gt;
$$
\text{Row}(A) = \{ \mathbf{y}^T A \mid \mathbf{y} \in \mathbb{R}^m \}
$$&lt;p&gt;
Equivalently, it is the column space of $ A^T $ ($ \text{Col}(A^T) $).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="def-null"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Null Space&lt;/strong&gt;&lt;a href="#def-null" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;The null space of matrix $ A $, denoted $ \text{Null}(A) $, is the set of all vectors $ \mathbf{x} $ such that $ A\mathbf{x} = \mathbf{0} $.
&lt;/p&gt;
$$
\text{Null}(A) = \{ \mathbf{x} \in \mathbb{R}^n \mid A\mathbf{x} = \mathbf{0} \}
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--definition" id="def-null"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Left Null Space&lt;/strong&gt;&lt;a href="#def-null" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;p&gt;The left null space of matrix $ A $, denoted $ \text{Null}(A^T) $, is the set of all vectors $ \mathbf{y} $ such that $ \mathbf{y}^T A = \mathbf{0} $.
&lt;/p&gt;
$$
\text{Null}(A^T) = \{ \mathbf{y} \in \mathbb{R}^m \mid \mathbf{y}^T A = \mathbf{0} \}
$$&lt;p&gt;
This is equivalent to the null space of $ A^T $.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="math-block math-block--theorem" id="subspaces"&gt;
&lt;div class="math-block-title"&gt;
&lt;strong&gt;Relationships Between the Subspaces&lt;/strong&gt;&lt;a href="#subspaces" class="math-block-anchor" aria-label="直接链接到此"&gt;¶&lt;/a&gt;&lt;/div&gt;
&lt;div class="math-block-content"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Orthogonality&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;The column space $ \text{Col}(A) $ is orthogonal to the left null space $ \text{Null}(A^T) $ (in $ \mathbb{R}^m $).&lt;/li&gt;
&lt;li&gt;The row space $ \text{Row}(A) $ is orthogonal to the null space $ \text{Null}(A) $ (in $ \mathbb{R}^n $).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dimension Relationships&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;$ \text{rank}(A) = \dim(\text{Col}(A)) = \dim(\text{Row}(A)) $&lt;/li&gt;
&lt;li&gt;$ \dim(\text{Null}(A)) = n - \text{rank}(A) $&lt;/li&gt;
&lt;li&gt;$ \dim(\text{Null}(A^T)) = m - \text{rank}(A) $&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id="eigenvalues-and-eigenvectors"&gt;Eigenvalues and eigenvectors
&lt;/h4&gt;</description></item><item><title>Hello World</title><link>https://cxzhou.com/p/hello-world/</link><pubDate>Sun, 22 Jun 2025 20:00:00 +0800</pubDate><guid>https://cxzhou.com/p/hello-world/</guid><description>&lt;img src="https://cxzhou.com/p/hello-world/cover.jpg" alt="Featured image of post Hello World" /&gt;&lt;p&gt;Hello World! This is my first post.&lt;/p&gt;
&lt;p&gt;This will be kept as an template.&lt;/p&gt;
&lt;p&gt;公式展示：$e^{it}=cost+i \cdot sint$&lt;/p&gt;
$$
F(t)=\int_0^t f(x)dx
$$&lt;p&gt;For more information about this theme, check the documentation: &lt;a class="link" href="https://stack.jimmycai.com/" target="_blank" rel="noopener"
&gt;https://stack.jimmycai.com/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Photo by &lt;a class="link" href="https://unsplash.com/@pawel_czerwinski" target="_blank" rel="noopener"
&gt;Pawel Czerwinski&lt;/a&gt; on &lt;a class="link" href="https://unsplash.com/" target="_blank" rel="noopener"
&gt;Unsplash&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>ODE期末复习</title><link>https://cxzhou.com/p/ode%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</link><pubDate>Sun, 22 Jun 2025 20:14:00 +0800</pubDate><guid>https://cxzhou.com/p/ode%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</guid><description>&lt;p&gt;##　线性方程&lt;/p&gt;
&lt;h3 id="齐次线性微分方程组"&gt;齐次线性微分方程组
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;形式：
&lt;/p&gt;
$$
\frac{d\mathbf{x}}{dt}=\mathbf{A}(t)\mathbf{x}
$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通解：
&lt;/p&gt;
$$
\mathbf{x}(t)=\mathbf{X}(t)\mathbf{c}
$$&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\mathbf{X}(t)$是基解矩阵，判断基解矩阵（线性无关）充要条件：&lt;/p&gt;
&lt;p&gt;$det(\mathbf{X}(t))$恒不为零$\iff$$\exist t_0, det(\mathbf{X}(t))=det(\mathbf{X}(t_0))exp(\int_{t_0}^t tr(\mathbf{A}(\tau)d\tau) \neq 0$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叠加原理（解的线性组合还是解）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="非齐次线性微分方程组"&gt;非齐次线性微分方程组
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;形式：
&lt;/p&gt;
$$
\frac{d\mathbf{x}}{dt}=\mathbf{A}(t)\mathbf{x}+\mathbf{f}(t)
$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通解：
&lt;/p&gt;
$$
\mathbf{x}(t)=\mathbf{X}(t)\mathbf{c}+\mathbf{x}^*(t)
$$&lt;ul&gt;
&lt;li&gt;$\mathbf{x}^*(t)$通过常数变易法求得，
$$
\mathbf{x}^*(t)=\mathbf{X}(t)\int_{t_0}^{t}\mathbf{X}^{-1}(\tau)\mathbf{f}(\tau)d\tau
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="高阶线性微分方程"&gt;高阶线性微分方程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;形式：
&lt;/p&gt;
$$
\frac{d^n x}{dt^n}+a_1(t)\frac{d^{n-1} x}{dt^{n-1}}+\cdots+a_n(t)x=f(t)
$$&lt;p&gt;
升维降阶：&lt;/p&gt;
&lt;p&gt;令
&lt;/p&gt;
$$
x_1=x, x_2=\frac{dx}{dt}, \cdots, x_n=\frac{d^{n-1} x}{dt^{n-1}}
$$&lt;p&gt;
转换为一阶线性微分方程组
&lt;/p&gt;
$$
\frac{d\mathbf{x}}{dt}=\mathbf{A}(t)\mathbf{x}+\mathbf{f}(t)
$$&lt;p&gt;
其中
&lt;/p&gt;
$$
\mathbf{A}(t)=\left( \begin{matrix}
0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1 \\
-a_n(t) &amp; -a_{n-1}(t) &amp; -a_{n-2}(t) &amp; \cdots &amp; -a_1(t) \\
\end{matrix}\right),
$$$$
\mathbf{f}(t)=\left(\begin{matrix}
0 \\
0 \\
\vdots \\
0 \\
f(t)
\end{matrix}\right), \mathbf{x}=\left(\begin{matrix}
x_1 \\
x_2 \\
\vdots \\
x_{n-1} \\
x_n
\end{matrix}\right)
$$&lt;p&gt;对应基解矩阵第一行即为原方程的n个线性无关解，同理，原方程的n个线性无关解通过求导可得基解矩阵.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断基解矩阵（线性无关）充要条件：&lt;/p&gt;
&lt;p&gt;$W(t)=det(\mathbf{X}(t))$恒不为零$\iff$$\exist t_0, W(t)=W(t_0)exp(\int_{t_0}^t tr(\mathbf{A}(\tau)d\tau)=W(t_0)exp(\int_{t_0}^t -a_1(\tau)d\tau) \neq 0$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个特例：
&lt;/p&gt;
$$
\frac{d^2x}{dt^2}+a_1(t)\frac{dx}{dt}+a_2(t)x=0
$$&lt;p&gt;
已知一个非零解$x_1(t)$，通解为
&lt;/p&gt;
$$
x(t)=x_1(t)(C_2+C_1\int\frac{1}{x_1^2(t)}e^{-\int a_1(t)dt}dt)
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="复值解"&gt;复值解
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;复值线性方程组
$$
\frac{d\mathbf{z}}{dt}=\mathbf{A}(t)\mathbf{z}+\mathbf{f}(t)
$$
其中
$$
\mathbf{z}(t)=\mathbf{x}(t)+i\mathbf{y}(t), \newline
\mathbf{A}(t)=\mathbf{A}_R(t)+i\mathbf{A}_I(t), \newline
\mathbf{f}(t)=\mathbf{f}_R(t)+i\mathbf{f}_I(t).
$$
等价于实方程组
$$
\frac{d}{dt}\left(\begin{matrix} \mathbf{x} \\ \mathbf{y} \end{matrix}\right)=\left(\begin{matrix} \mathbf{A}_R(t) &amp; -\mathbf{A}_I(t) \\ \mathbf{A}_I(t) &amp; \mathbf{A}_R(t) \end{matrix}\right)\left(\begin{matrix} \mathbf{x} \\ \mathbf{y} \end{matrix}\right)+\left(\begin{matrix} \mathbf{f}_R(t) \\ \mathbf{f}_I(t) \end{matrix}\right)
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="常系数线性方程"&gt;常系数线性方程
&lt;/h2&gt;&lt;h3 id="微分算子处理常系数高阶线性方程"&gt;微分算子处理常系数高阶线性方程
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$\frac{d^n x}{dt^n}+a_1\frac{d^{n-1} x}{dt^{n-1}}+\cdots+a_nx=f(t)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微分算子: $D=\frac{d}{dt}$, $D^n=\frac{d^n}{dt^n}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方程可化为算子形式：$P(D)x=f(t)$, $P(D)\overset{def}{=}D^n+a_1D^{n-1}+\cdots+a_{n-1}D+a_n$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="齐次问题"&gt;齐次问题
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;欧拉待定指数函数法&lt;/strong&gt;：寻找形如$x(t)=e^{\lambda t}$的解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;求解特征方程：
&lt;/p&gt;
$$
P(\lambda)=\lambda^n+a_1\lambda^{n-1}+\cdots+a_{n-1}\lambda+a_n=0
$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设有$r$个互异的实特征根$\lambda_1, \lambda_2 \cdots, \lambda_r$，$l$对互异的复特征根$\alpha_1\pm i\beta_1, \alpha_2\pm i\beta_2, \cdots, \alpha_l\pm i\beta_l$，重数分别为$n_1, n_2, \cdots, n_r$和$m_1, m_2, \cdots, m_l$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本解组如下：
&lt;/p&gt;
$$
e^{\lambda_k t},\space te^{\lambda_k t},\space \cdots,\space t^{n_k-1}e^{\lambda_k t}\space\space\space\space (k=1,2,\cdots,r),\newline
e^{\alpha_jt}cos\beta_jt,\space te^{\alpha_jt}cos\beta_jt,\space \cdots,\space t^{m_j-1}e^{\alpha_jt}cos\beta_jt \space\space\space\space (j=1,2,\cdots,l),\newline
e^{\alpha_jt}sin\beta_jt,\space te^{\alpha_jt}sin\beta_jt,\space \cdots,\space t^{m_j-1}e^{\alpha_jt}sin\beta_jt \space\space\space\space (j=1,2,\cdots,l)
$$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="非齐次问题"&gt;非齐次问题
&lt;/h4&gt;&lt;p&gt;求出一个特解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;算子解法
&lt;/p&gt;
$$
x^*(t)=\frac{1}{P(D)}f(t)
$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具体算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解析法：对$k$次多项式$f_k(t)$，若$\frac{1}{P(x)}$在$x=0$处解析，且可（泰勒）展开为
&lt;/p&gt;
$$
\frac{1}{P(x)}=Q_k(x)+H_k(x)
$$&lt;p&gt;
其中$Q_K(x)$为$k$次多项式，$H_k(x)$为$k+1$次以上高阶项，&lt;/p&gt;
&lt;p&gt;有
&lt;/p&gt;
$$
\frac{1}{P(D)}f_k(t)=Q_k(D)f_k(t)
$$&lt;p&gt;
(泰勒公式：$f(0)+\frac{f\prime(0)}{1!}x+\cdots+\frac{f^{(n)}(0)}{n!}x^n+\cdots$)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代换法：&lt;/p&gt;
&lt;p&gt;要求$P(\lambda)\neq0$，$\frac{1}{P(D)}e^{\lambda t}=\frac{1}{P(\lambda)}e^{\lambda t}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二项式法：&lt;/p&gt;
&lt;p&gt;$\frac{1}{P(D)}e^{\lambda t}v(t)=e^{\lambda t}\frac{1}{P(D+\lambda)}v(t)$&lt;/p&gt;
&lt;p&gt;常用技巧：$v(t)=1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="常系数线性方程组"&gt;常系数线性方程组
&lt;/h3&gt;$$
\frac{d}{dt}\left(\begin{matrix}x_1 \\ \vdots \\ x_n \end{matrix}\right)=\left(\begin{matrix}a_{11} &amp; \cdots &amp; a_{1n} \\ \vdots &amp;&amp; \vdots \\ a_{n1} &amp; \cdots &amp; a_{nn} \end{matrix}\right)\left(\begin{matrix}x_1 \\ \vdots \\ x_n \end{matrix}\right)+\left(\begin{matrix}f_1(t) \\ \vdots \\ f_n(t) \end{matrix}\right)
$$&lt;p&gt;通解形式：
&lt;/p&gt;
$$
\mathbf{x}(t)=e^{t\mathbf{A}}\mathbf{c}+e^{t\mathbf{A}}\int_{t_0}^te^{-s\mathbf{A}}\mathbf{f}(s)ds
$$&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;求解$e^{t\mathbf{A}}$：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;借助$Jordan$标准型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;求$Jordan$链：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;求解$\mathbf{A}$的特征值$\lambda_1, \lambda_2, \cdots, \lambda_s$，重数分别为$n_1, n_2, \cdots, n_s$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于$\lambda_i, i=1,2,\cdots, s$求解广义特征向量：
&lt;/p&gt;
$$
(\mathbf{A}-\lambda_i\mathbf{I})^{n_i}\mathbf{\gamma}=\mathbf{0}
$$&lt;p&gt;
有$n_i$个线性无关的广义特征向量，$\gamma_1^{(i)}, \gamma_2^{(i)}, \cdots, \gamma_{n_i}^{(i)}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于每一个广义特征向量$\gamma_j^{(i)}, j=1,2,\cdots, n_i; i=1,2,\cdots, s$，求得对应的$Jordan$链：
&lt;/p&gt;
$$
\gamma_{j,0}^{(i)}=\gamma_j^{(i)}, \newline
\gamma_{j,1}^{(i)}=(\mathbf{A}-\lambda_i\mathbf{I})\gamma_{j,0}^{(i)}, \newline
\cdots \newline
\gamma_{j,n_1-1}^{(i)}=(\mathbf{A}-\lambda_i\mathbf{I})\gamma_{j,n_i-2}^{(i)}, \newline
$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对应基解矩阵中的一列：
&lt;/p&gt;
$$
e^{\lambda_i t}[\gamma_{j,0}^{(i)}+\frac{t}{1!}\gamma_{j,1}^{(i)}+\cdots+\frac{t^{n_i-1}}{(n_i-1)!}\gamma_{j,n_i-1}^{(i)}]
$$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组装即得基解矩阵&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如有复根，直接取实部即可（欧拉公式：$e^{it}=cost+isint$)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="动力系统"&gt;动力系统
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动力系统概念
&lt;/p&gt;
$$
\frac{d\mathbf{x}}{dt}=\mathbf{f}(\mathbf{x})
$$&lt;p&gt;
右端函数只与$\mathbf{x}$有关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;平衡点/奇点&lt;/strong&gt;：从该点出发的轨道一直驻留在该点，对应一个定常解$\mathbf{x}(t)\equiv\mathbf{x}_0$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;闭轨/周期轨&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lyapunov稳定性"&gt;Lyapunov稳定性
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;各种稳定性的定义：张伟年p162-163&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判别
&lt;/p&gt;
$$
\frac{d\mathbf{x}}{dt}=\mathbf{A}\mathbf{x}
$$&lt;p&gt;
的零解稳定性情况，若有段函数有高阶部分，判断高阶部分是否满足：
&lt;/p&gt;
$$
\mathbf{R}(t,\mathbf{0})\equiv\mathbf{0}, \lim_{\|\mathbf{x}\| \to \mathbf{0}}
\frac{\|\mathbf{R}(t, \mathbf{x})\|}{\|\mathbf{x}\|} = 0
$$&lt;p&gt;
若满足则可只考察线性部分.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;渐近稳定：当且仅当$\mathbf{A}$的全部特征值实部均为负数&lt;/li&gt;
&lt;li&gt;稳定：当且仅当$\mathbf{A}$的全部特征值实部均为非正数，且实部为零的特征值对应的$Jordan$块都是一阶&lt;/li&gt;
&lt;li&gt;不稳定：当且仅当$\mathbf{A}$的特征值至少一个实部为正，或至少一个实部为零的特征值对应的$Jordan$块大于一阶&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lyapunov直接法"&gt;Lyapunov直接法
&lt;/h3&gt;&lt;p&gt;构造Lyapunov函数，满足函数定正（至少在一个邻域内）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;稳定：导数常负&lt;/li&gt;
&lt;li&gt;渐近稳定：导数定 负&lt;/li&gt;
&lt;li&gt;不稳定：导数定正&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="平衡点分析"&gt;平衡点分析
&lt;/h3&gt;&lt;p&gt;只考虑平面自治系统：
&lt;/p&gt;
$$
\frac{dx}{dt}=X(x, y), \frac{dy}{dt}=Y(x, y)
$$&lt;p&gt;
平衡点：$X(x,y)=0, Y(x,y)=0$&lt;/p&gt;
&lt;p&gt;分析步骤：
&lt;/p&gt;
$$
\frac{dx}{dt}=ax+by, \frac{dy}{dt}=cx+dy, \newline
\frac{d}{dt}\left(\begin{matrix}x \\ y\end{matrix}\right)=\mathbf{A}\left(\begin{matrix}x \\ y\end{matrix}\right)
$$&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过可逆变换，原方程组变为
&lt;/p&gt;
$$
\frac{d}{dt}\left(\begin{matrix}u \\ v\end{matrix}\right)=\mathbf{J}\left(\begin{matrix}u \\ v\end{matrix}\right)
$$&lt;p&gt;
$\mathbf{J}=\mathbf{P^{-1}AP}$&lt;/p&gt;
&lt;p&gt;其中$\mathbf{J}$有三种形式：
&lt;/p&gt;
$$
\left(\begin{matrix}
\lambda &amp; 0 \\
0 &amp; \mu \\
\end{matrix}\right), \left(\begin{matrix}
\lambda &amp; 0 \\
1 &amp; \lambda \\
\end{matrix}\right), \left(\begin{matrix}
\alpha &amp; \beta \\
-\beta &amp; \alpha \\
\end{matrix}\right)
$$&lt;p&gt;
即分别对应矩阵$\mathbf{A}$有两个一重特征值，一个二重特征值和一对共轭复特征值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类讨论&lt;/p&gt;
&lt;p&gt;仅考虑非退化平衡点，$det(\mathbf{A})\neq0$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$\lambda=\mu$&lt;/p&gt;
&lt;p&gt;$\lambda&lt;0$, 渐近稳定；$\lambda&gt;0$, 不稳定；&lt;/p&gt;
&lt;p&gt;同时平衡点附近轨道均为过原点直线，方向由$\lambda$正负决定；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;星形结点/临界结点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\lambda\neq\mu, \lambda\mu&gt;0$&lt;/p&gt;
&lt;p&gt;均正，不稳定；均负，稳定；&lt;/p&gt;
&lt;p&gt;抛物线，谁的绝对值小就与对应的轴相切；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两向结点/正常结点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\lambda\neq\mu, \lambda\mu&lt;0$&lt;/p&gt;
&lt;p&gt;不稳定；&lt;/p&gt;
&lt;p&gt;$\lambda&lt;0, \mu&gt;0$, 渐近$v$轴;$\lambda&gt;0, \mu&lt;0$, 渐近$u$轴;（渐近正方向）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;鞍点&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二种&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单向结点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$\lambda&lt;0$&lt;/p&gt;
&lt;p&gt;渐近稳定；&lt;/p&gt;
&lt;p&gt;像正弦函数从两侧逼近原点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\lambda&gt;0$&lt;/p&gt;
&lt;p&gt;不稳定&lt;/p&gt;
&lt;p&gt;像负正弦函数向两侧远离原点；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;$\alpha\neq0$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;焦点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;螺旋线，$\beta$正顺负逆&lt;/p&gt;
&lt;p&gt;$\alpha&gt;0$不稳定，$\alpha&lt;0$渐近稳定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$\alpha=0$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同心圆&lt;/p&gt;
&lt;p&gt;稳定但不渐近稳定&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除&lt;strong&gt;中心&lt;/strong&gt;以外的&lt;strong&gt;初等平衡点&lt;/strong&gt;（非退化）称为&lt;strong&gt;粗的&lt;/strong&gt;，其余为&lt;strong&gt;细的&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="极限环"&gt;极限环
&lt;/h3&gt;&lt;p&gt;化为极坐标后讨论&lt;/p&gt;
&lt;p&gt;转化方式类似首次积分中的方法：
&lt;/p&gt;
$$
rr\prime=xx\prime+yy\prime, \newline
-r^2\theta\prime=yx\prime-xy\prime
$$$$
\frac{d^2x}{dt}+2\mu\frac{dx}{dt}+x=f(t)
$$&lt;p&gt;
$f(t)$是$T$-周期函数，$x(t)$是否存在$T$-周期解?（$\mu\geq1$）&lt;/p&gt;
&lt;p&gt;判别
&lt;/p&gt;
$$
\frac{d\mathbf{x}}{dt}=\mathbf{A}\mathbf{x}+\mathbf{f}(\mathbf{x})
$$&lt;p&gt;
的零解稳定性情况是否与$\frac{d\mathbf{x}}{dt}=\mathbf{A}\mathbf{x}$一致，其中$\mathbf{f}(\mathbf{x})=O(x^2)$.&lt;/p&gt;</description></item><item><title>Image gallery</title><link>https://cxzhou.com/p/image-gallery/</link><pubDate>Wed, 10 Jul 2024 00:00:00 +0800</pubDate><guid>https://cxzhou.com/p/image-gallery/</guid><description>&lt;img src="https://cxzhou.com/p/image-gallery/2.jpg" alt="Featured image of post Image gallery" /&gt;&lt;p&gt;Hugo theme Stack supports the creation of interactive image galleries using Markdown. It&amp;rsquo;s powered by &lt;a class="link" href="https://photoswipe.com/" target="_blank" rel="noopener"
&gt;PhotoSwipe&lt;/a&gt; and its syntax was inspired by &lt;a class="link" href="https://typlog.com/" target="_blank" rel="noopener"
&gt;Typlog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo&amp;rsquo;s page bundle feature to read the dimensions of the image. &lt;strong&gt;External images are not supported.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="result"&gt;Result
&lt;/h2&gt;&lt;p&gt;&lt;figure class="gallery-figure"&gt;
&lt;img src="https://cxzhou.com/p/image-gallery/2_hu_4dc3db583644b205.jpg" alt="Image 2" width="800" height="1200" loading="lazy"&gt;
&lt;figcaption class="gallery-figcaption"&gt;
&lt;div class="caption-title"&gt;&lt;strong&gt;Image 2&lt;/strong&gt;&lt;/div&gt;
&lt;div class="exif-details"&gt;&lt;/div&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id="日本旅行"&gt;日本旅行
&lt;/h3&gt;&lt;div class="exif-gallery"&gt;
&lt;figure class="gallery-figure"&gt;
&lt;img src="https://cxzhou.com/p/image-gallery/test_hu_b3630236bf2588ab.jpg" alt="test" width="800" height="600" loading="lazy"&gt;
&lt;figcaption class="gallery-figcaption"&gt;
&lt;div class="caption-title"&gt;&lt;strong&gt;test&lt;/strong&gt;&lt;/div&gt;
&lt;div class="exif-details"&gt;&lt;div class="exif-item"&gt;🗓️&lt;span&gt;2024-07-01 15:27&lt;/span&gt;&lt;/div&gt;&lt;div class="exif-item"&gt;📷&lt;span&gt;iPhone 14 Pro&lt;/span&gt;&lt;/div&gt;&lt;div class="exif-item"&gt;렌즈&lt;span&gt;iPhone 14 Pro front camera 2.69mm f/1.9&lt;/span&gt;&lt;/div&gt;&lt;div class="exif-item"&gt;⚙️&lt;span&gt;ƒ/1.9&lt;/span&gt;&lt;/div&gt;&lt;div class="exif-item"&gt;🔭&lt;span&gt;3mm&lt;/span&gt;&lt;/div&gt;&lt;div class="exif-item"&gt;📍&lt;span&gt;&lt;a href="https://www.google.com/maps?q=35.01589722166667,135.67344722166666" target="_blank" rel="noopener noreferrer"&gt;在地图上查看&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Photo by &lt;a class="link" href="https://unsplash.com/@mymind" target="_blank" rel="noopener"
&gt;mymind&lt;/a&gt; and &lt;a class="link" href="https://unsplash.com/@lukechesser" target="_blank" rel="noopener"
&gt;Luke Chesser&lt;/a&gt; on &lt;a class="link" href="https://unsplash.com/" target="_blank" rel="noopener"
&gt;Unsplash&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>Archives</title><link>https://cxzhou.com/archives/</link><pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate><guid>https://cxzhou.com/archives/</guid><description/></item><item><title>About me</title><link>https://cxzhou.com/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cxzhou.com/about/</guid><description>&lt;div class="contact-info"&gt;
&lt;span&gt;📧 &lt;strong&gt;邮件:&lt;/strong&gt; &lt;a href="mailto:alanzhou10086@gmail.com"&gt;alanzhou10086@gmail.com&lt;/span&gt;
&lt;span&gt;📧 &lt;strong&gt;邮件:&lt;/strong&gt; &lt;a href="mailto:alanzhou@sjtu.edu.cn"&gt;alanzhou@sjtu.edu.cn&lt;/a&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;h2 id="教育背景"&gt;教育背景
&lt;/h2&gt;
&lt;div class="timeline"&gt;
&lt;div class="timeline-item"&gt;
&lt;div class="timeline-marker"&gt;&lt;/div&gt;
&lt;div class="timeline-content"&gt;
&lt;div class="timeline-header"&gt;
&lt;h4 class="timeline-title"&gt;学士：经济学-数学与应用数学&lt;/h4&gt;
&lt;span class="timeline-date"&gt;2027年 毕业&lt;/span&gt;
&lt;/div&gt;
&lt;h5 class="timeline-subtitle"&gt;上海交通大学&lt;/h5&gt;
&lt;div class="timeline-body"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主修课程&lt;/strong&gt;: 实变函数, 常微分方程, 概率论, 微观经济学, 宏观经济学, 计量经济学, 货币金融学, 数据结构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;荣誉&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;全国中学生物理竞赛江苏省一等奖&lt;/li&gt;
&lt;li&gt;美国大学生数学建模大赛H奖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;To be continued&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="项目经历"&gt;项目经历
&lt;/h2&gt;
&lt;div class="timeline"&gt;
&lt;div class="timeline-item"&gt;
&lt;div class="timeline-marker"&gt;&lt;/div&gt;
&lt;div class="timeline-content"&gt;
&lt;div class="timeline-header"&gt;
&lt;h4 class="timeline-title"&gt;数据资产入表暑期科研&lt;/h4&gt;
&lt;span class="timeline-date"&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="timeline-body"&gt;
&lt;strong&gt;项目简介&lt;/strong&gt;调研数据资产入表现状，参与撰写数据资产一书，系统介绍数据资产及其入表工作。&lt;br&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="timeline-item"&gt;
&lt;div class="timeline-marker"&gt;&lt;/div&gt;
&lt;div class="timeline-content"&gt;
&lt;div class="timeline-header"&gt;
&lt;h4 class="timeline-title"&gt;“深海牧场”大创项目&lt;/h4&gt;
&lt;span class="timeline-date"&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="timeline-body"&gt;
&lt;strong&gt;项目简介&lt;/strong&gt;依托于深海勇士号采集的数据进行图像拼接，统计分析，建立预测模型。&lt;br&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="timeline-item"&gt;
&lt;div class="timeline-marker"&gt;&lt;/div&gt;
&lt;div class="timeline-content"&gt;
&lt;div class="timeline-header"&gt;
&lt;h4 class="timeline-title"&gt;股市波动对早产的影响（在研）&lt;/h4&gt;
&lt;span class="timeline-date"&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class="timeline-body"&gt;
&lt;strong&gt;项目简介&lt;/strong&gt;使用计量方法研究股市波动对早产的影响，宏观经济不确定性如何转化为个体层面，揭示社会经济压力对母婴健康的深远影响。&lt;br&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 id="专业技能"&gt;专业技能
&lt;/h2&gt;
&lt;div class="skills-grid"&gt;
&lt;div class="skill-card"&gt;
&lt;span class="skill-category"&gt;编程语言:&lt;/span&gt;
&lt;div class="skill-tags"&gt;
&lt;span class="skill-tag"&gt;Python&lt;/span&gt;
&lt;span class="skill-tag"&gt;C&amp;#43;&amp;#43;&lt;/span&gt;
&lt;span class="skill-tag"&gt;Rust&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="skill-card"&gt;
&lt;span class="skill-category"&gt;数据分析:&lt;/span&gt;
&lt;div class="skill-tags"&gt;
&lt;span class="skill-tag"&gt;STATA&lt;/span&gt;
&lt;span class="skill-tag"&gt;Matlab&lt;/span&gt;
&lt;span class="skill-tag"&gt;Wolfram&lt;/span&gt;
&lt;span class="skill-tag"&gt;MySQL&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="skill-card"&gt;
&lt;span class="skill-category"&gt;语言:&lt;/span&gt;
&lt;div class="skill-tags"&gt;
&lt;span class="skill-tag"&gt;CET-6&lt;/span&gt;
&lt;span class="skill-tag"&gt;IELTS 7.0&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>Links</title><link>https://cxzhou.com/links/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cxzhou.com/links/</guid><description>&lt;h2 id="-friends--teachers"&gt;🤝 Friends &amp;amp; Teachers
&lt;/h2&gt;
&lt;div class="links-grid"&gt;
&lt;a class="link-card" href="https://yevzh.gitHub.io" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;wmgg的Blog&lt;/h3&gt;
&lt;div class="link-description"&gt;最爱的wmgg，SJTU CS硕士研究生在读&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://wangyixiao.top" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;Yixiao&amp;rsquo;s Blog&lt;/h3&gt;
&lt;div class="link-description"&gt;优秀！交大SE本科在读&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://dyas.top" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;豆芽酱的网站&lt;/h3&gt;
&lt;div class="link-description"&gt;豆芽酱，很厉害的电院同学&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://xzlim.com" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;RC&amp;rsquo;s Page&lt;/h3&gt;
&lt;div class="link-description"&gt;我的中级微观经济学老师，非常nice的教授in ACEM！&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://jhqian.org" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;钱军辉老师的主页&lt;/h3&gt;
&lt;div class="link-description"&gt;我的中级宏观经济学老师，独特且有用的听课体验！&lt;/div&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;h2 id="-有用的链接"&gt;🛠️ 有用的链接
&lt;/h2&gt;
&lt;div class="links-grid"&gt;
&lt;a class="link-card" href="https://github.com" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;div class="link-description"&gt;全球最大的&lt;del&gt;代码托管&lt;/del&gt;男性交友平台。&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://gemini.google.com" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;Google Gemini&lt;/h3&gt;
&lt;div class="link-description"&gt;好用的ai&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://chatgpt.com/" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;ChatGPT&lt;/h3&gt;
&lt;div class="link-description"&gt;好用的ai&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://claude.ai/" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;Claude&lt;/h3&gt;
&lt;div class="link-description"&gt;好用的ai&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://liaox.ai/ic/ZRKW3U" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;liaoxAI&lt;/h3&gt;
&lt;div class="link-description"&gt;划算的镜像站&lt;/div&gt;
&lt;/a&gt;
&lt;/div&gt;
&lt;h2 id="-ecy蒸鹅心"&gt;🌸 ecy蒸鹅心
&lt;/h2&gt;
&lt;div class="links-grid"&gt;
&lt;a class="link-card" href="https://www.bilibili.com" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;Bilibili&lt;/h3&gt;
&lt;div class="link-description"&gt;国内领先的年轻人文化社区。&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://www.pixiv.net" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;Pixiv&lt;/h3&gt;
&lt;div class="link-description"&gt;一个以插图、漫画和小说艺术为中心的社交网络服务。&lt;/div&gt;
&lt;/a&gt;
&lt;a class="link-card" href="https://bgm.tv/" target="_blank" rel="noopener noreferrer"&gt;
&lt;h3&gt;Bangumi&lt;/h3&gt;
&lt;div class="link-description"&gt;ecy资料库&lt;/div&gt;
&lt;/a&gt;
&lt;/div&gt;</description></item><item><title>Search</title><link>https://cxzhou.com/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cxzhou.com/search/</guid><description/></item></channel></rss>